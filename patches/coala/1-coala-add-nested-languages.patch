From c42afec17773349d38b319a0c8a331f1cadaa013 Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Wed, 21 Aug 2019 16:17:44 +0530
Subject: [PATCH 01/19] NlSection.py: Add NlSection modules and it's tests

This PR adds the class NlSection.

In Nested Language mode, we divide the original file
into various sections. These sections are called as
`pure language sections` and `mixed language` sections.

NlSection helps us to define these sections and also
maitain the information of the start and the end position
of these sections in the original file. This information
helps us while linting.

This has an similar implementation to that of the SourceRange
of coala which is used to store the information about the
affected code.

This PR also has the tests for NlSection.
---
 coalib/nestedlib/NlSection.py    | 122 +++++++++++++++++++++++++++++++
 tests/nestedlib/NlSectionTest.py |  79 ++++++++++++++++++++
 2 files changed, 201 insertions(+)
 create mode 100755 coalib/nestedlib/NlSection.py
 create mode 100755 tests/nestedlib/NlSectionTest.py

diff --git a/coalib/nestedlib/NlSection.py b/coalib/nestedlib/NlSection.py
new file mode 100755
index 000000000..657b3ab7e
--- /dev/null
+++ b/coalib/nestedlib/NlSection.py
@@ -0,0 +1,122 @@
+from coala_utils.decorators import (
+    enforce_signature, generate_ordering, generate_repr, get_public_members)
+from coalib.nestedlib.NlSectionPosition import NlSectionPosition
+from coalib.results.TextRange import TextRange
+
+@generate_repr('file', 'index', 'language', 'start', 'end', 'linted_start',
+               'linted_end')
+class NlSection(TextRange):
+
+    @enforce_signature
+    def __init__(self,
+                 file: str,
+                 index: int,
+                 language: str,
+                 start: NlSectionPosition,
+                 end: (NlSectionPosition, None) = None,
+                 temp_file=None):
+        """
+        Create a new NlSection.
+
+        :param start:       A NlSectionPosition indicating the start of the
+                            section in original file.
+        :param end:         A NlSectionPosition indicating the end of the
+                            section in the original file.
+                            If ``None`` is given, the start object will be used
+                            here. end must be in the same file and be greater
+                            than start as negative ranges are not allowed.
+        :param language:    The programming language of the lines.
+        :param index:       The index of the nl_section.
+        :param file:        The name of the original file
+        :param temp_file:   The name of the temporary segregated file
+        :raises TypeError:  Raised when
+                            - start is not of type NlSectionPosition.
+                            - end is neither of type NlSectionPosition, nor
+                              is it None.
+                            - file is not of type str
+                            - index is not of type int
+                            - language is not of type str
+        :raises ValueError: Raised when file of start and end mismatch.
+        """
+        TextRange.__init__(self, start, end)
+        self.index = index
+        self.language = language
+
+        """
+        :linted_start: The start of the section in the linted file.Initially it
+                       is same as that of the start of the original file. It
+                       changes only when any patches are applied on that line.
+        :linted_end:   The end of the section in the linted file.Initially it
+                       is same as that of the end of the original file. It
+                       changes only when any patches are applied on that line.
+                       If ``None`` is given, the start object will be used
+                       here
+        """
+        self.linted_start = NlSectionPosition(file, start.line, start.column)
+        if end:
+            self.linted_end = NlSectionPosition(file, end.line, end.column)
+        else:
+            self.linted_end = NlSectionPosition(file, start.line, start.column)
+
+        if self.start.file != self.end.file:
+            raise ValueError('File of start and end position do not match.')
+
+    @classmethod
+    def from_values(cls,
+                    file,
+                    index,
+                    language,
+                    start_line=None,
+                    start_column=None,
+                    end_line=None,
+                    end_column=None,):
+        start = NlSectionPosition(file, start_line, start_column)
+        if end_line or (end_column and end_column > start_column):
+            end = NlSectionPosition(file, end_line if end_line else start_line,
+                                    end_column)
+        else:
+            end = None
+        return cls(file, index, language, start, end)
+
+    @property
+    def file(self):
+        return self.start.file
+
+    def __str__(self):
+        """
+        Create a string representation of the NlSection object.
+
+        If the whole file is affected, then just the filename is shown.
+
+        >>> str(NlSection.from_values('test_file', 1, 'html', None, None,
+        ... None, None))
+        '...test_file: 1: html: '
+
+        If the whole line is affected, then just the filename with starting
+        line number and ending line number is shown.
+
+        >> str(NlSection.from_values('test_file', 1, 'html', 1, None, 2, None))
+        '...test_file: 1: html: L1: L2: L1: L2'
+
+        This is the general case where particular column and line are
+        specified. It shows the starting line and column and ending line
+        and column, with filename in the beginning.
+
+        >>> str(NlSection.from_values('test_file', 1, 'html', 1, 1, 2, 1))
+        '...test_file: 1: html: L1 C1: L2 C1: L1 C1: L2 C1'
+        """
+        section_details = '{0.index}: {0.language}: '
+        if self.start.line is None and self.end.line is None:
+            format_str = '{0.start.file}: ' + section_details
+        elif self.start.column is None and self.end.column is None:
+            format_str = ('{0.start.file}: ' + section_details +
+                          'L{0.start.line}: L{0.end.line}:' +
+                          ' L{0.linted_start.line}: L{0.linted_end.line}')
+        else:
+            format_str = ('{0.start.file}: ' + section_details +
+                          'L{0.start.line} C{0.start.column}: ' +
+                          'L{0.end.line} C{0.end.column}: ' +
+                          'L{0.linted_start.line} C{0.linted_start.column}: '
+                          + 'L{0.linted_end.line} C{0.linted_end.column}')
+
+        return format_str.format(self)
diff --git a/tests/nestedlib/NlSectionTest.py b/tests/nestedlib/NlSectionTest.py
new file mode 100755
index 000000000..63a51d348
--- /dev/null
+++ b/tests/nestedlib/NlSectionTest.py
@@ -0,0 +1,79 @@
+import unittest
+
+from coalib.nestedlib.NlSection import NlSection
+from coalib.nestedlib.NlSectionPosition import NlSectionPosition
+
+
+class NlSectionTest(unittest.TestCase):
+
+    def setUp(self):
+        self.nested_fileA_noline = NlSectionPosition('A', None, None)
+        self.nested_fileA_line2 = NlSectionPosition('A', 2)
+        self.nested_fileA_line4 = NlSectionPosition('A', 4)
+
+        self.nested_fileB_line4 = NlSectionPosition('B', 4)
+
+        self.nested_sectionA_index = 1
+        self.nested_sectionA_language = 'python'
+
+    def test_construction(self):
+        uut = NlSection(file='A', index=1, language='python',
+                        start=self.nested_fileA_noline)
+        self.assertEqual(uut.end, self.nested_fileA_noline)
+
+        uut = NlSection.from_values(file='A', index=1, language='python',
+                                    start_line=2, end_line=4)
+        self.assertEqual(self.nested_sectionA_index, uut.index)
+        self.assertEqual(self.nested_sectionA_language, uut.language)
+        self.assertEqual(self.nested_fileA_line2, uut.start)
+        self.assertEqual(self.nested_fileA_line4, uut.end)
+
+        uut = NlSection.from_values(file='A', index=1, language='python',
+                                    start_line=2, end_line=None,
+                                    end_column=None)
+        self.assertEqual(uut.end, self.nested_fileA_line2)
+
+    def test_file_property(self):
+        uut = NlSection(file='A', index=1, language='python',
+                        start=self.nested_fileA_noline)
+        self.assertRegex(uut.file, '.*A')
+
+    def test_invalid_arguments(self):
+        with self.assertRaises(TypeError):
+            NlSection(file=1, index='asd', language=2.5,
+                      start=self.nested_fileA_line2,
+                      end=self.nested_fileA_line4)
+
+        with self.assertRaises(TypeError):
+            NlSection(file='A', index=1, language='python',
+                      start=1)
+
+        with self.assertRaises(TypeError):
+            NlSection(file='A', index=1, language='python',
+                      start=self.nested_fileA_line2, end=1)
+
+    def test_argument_file(self):
+        # both NlSectionPositions should describe the same file
+        with self.assertRaises(ValueError):
+            NlSection(file='A', index=1, language='python',
+                      start=self.nested_fileA_line2,
+                      end=self.nested_fileB_line4)
+
+    def test_string_converstion(self):
+        uut = NlSection.from_values(file='A', index=1, language='python',
+                                    start_line=2)
+        self.assertRegex(str(uut), '.*A: 1: python: L2: L2: L2: L2')
+
+        uut = NlSection.from_values(file='A', index=1, language='python',
+                                    start_line=None, end_line=None)
+        self.assertRegex(str(uut), '.*A: 1: python')
+
+        uut = NlSection.from_values(file='A', index=1, language='python',
+                                    start_line=2, end_line=4)
+        self.assertRegex(str(uut), '.*A: 1: python: L2: L4: L2: L4')
+
+        uut = NlSection.from_values(file='A', index=1, language='python',
+                                    start_line=2, start_column=4,
+                                    end_line=4, end_column=8)
+        self.assertRegex(
+            str(uut), '.*A: 1: python: L2 C4: L4 C8: L2 C4: L4 C8')

From dd27757467bb3ef41b03dd076eecf60d792929a5 Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Wed, 21 Aug 2019 16:23:32 +0530
Subject: [PATCH 02/19] NlSectionPosition.py: Add NlSectionPosition

This PR adds the NlSectionPosition class.
NlSectionPosition class is a derived class of TextRange.
It gives finer control to set the position. These include
the line number and column number.

This is a derived class of TextPosition Object.
---
 coalib/nestedlib/NlSectionPosition.py    | 52 +++++++++++++++++++++
 tests/nestedlib/NlSectionPositionTest.py | 57 ++++++++++++++++++++++++
 2 files changed, 109 insertions(+)
 create mode 100755 coalib/nestedlib/NlSectionPosition.py
 create mode 100755 tests/nestedlib/NlSectionPositionTest.py

diff --git a/coalib/nestedlib/NlSectionPosition.py b/coalib/nestedlib/NlSectionPosition.py
new file mode 100755
index 000000000..be106b0e4
--- /dev/null
+++ b/coalib/nestedlib/NlSectionPosition.py
@@ -0,0 +1,52 @@
+from os.path import abspath
+
+
+from coala_utils.decorators import (
+    enforce_signature, generate_ordering, generate_repr, get_public_members)
+from coalib.results.TextPosition import TextPosition
+
+
+@generate_repr('file', 'line', 'column')
+@generate_ordering('file', 'line', 'column')
+class NlSectionPosition(TextPosition):
+
+    @enforce_signature
+    def __init__(self, file: str, line=None, column=None):
+        """
+        Creates a new NlSection Position object that represents the position of
+        a NlSection in the original source code having nested languages.
+
+        :param file:        The filename
+        :param line:        The line in the file or None, the first line is 1.
+        :param column:      The column indicating the character. The first one
+                            in a line is 1.
+        :raises TypeError:  Raised when
+                            - file is not a string or None
+                            - line or column are not integers
+        """
+        TextPosition.__init__(self, line, column)
+
+        self.filename = file
+        self._file = abspath(file)
+
+    # The values of linted_start and linted_end changes during appliaction of
+    # a patch. Hence we need a setter method
+    @TextPosition.line.setter
+    def line(self, value):
+        self._line = value
+
+    @TextPosition.column.setter
+    def column(self, value):
+        self._column = value
+
+    @property
+    def file(self):
+        return self._file
+
+    def __str__(self):
+        source_position = self.filename
+        if self.line is not None:
+            source_position += ':' + str(self.line)
+        if self.column is not None:
+            source_position += ':' + str(self.column)
+        return source_position
diff --git a/tests/nestedlib/NlSectionPositionTest.py b/tests/nestedlib/NlSectionPositionTest.py
new file mode 100755
index 000000000..2e1bd6aea
--- /dev/null
+++ b/tests/nestedlib/NlSectionPositionTest.py
@@ -0,0 +1,57 @@
+import unittest
+
+from coalib.nestedlib.NlSectionPosition import NlSectionPosition
+from coalib.results.TextPosition import ZeroOffsetError
+
+
+class NestedPositionTest(unittest.TestCase):
+
+    def test_initialization(self):
+        with self.assertRaises(TypeError):
+            NlSectionPosition(1, 'file')
+
+        with self.assertRaises(TypeError):
+            NlSectionPosition('file', 1.1)
+
+        with self.assertRaises(TypeError):
+            NlSectionPosition('file', 1, 1.1)
+
+        with self.assertRaises(ValueError):
+            NlSectionPosition('file', None, 1)
+
+        with self.assertRaises(ZeroOffsetError):
+            NlSectionPosition('file', 12, 0)
+
+        # The following values should work
+        NlSectionPosition('file', None, None)
+        NlSectionPosition('file', 4, None)
+        NlSectionPosition('file', 5, 4)
+
+    def test_string_conversion(self):
+        uut = NlSectionPosition('filename', 1)
+        self.assertRegex(
+            repr(uut),
+            "<NlSectionPosition object\\(file='.*filename', line=1, "
+            'column=None\\) at 0x[0-9a-fA-F]+>')
+        self.assertEqual(str(uut), 'filename:1')
+
+        uut = NlSectionPosition('None', None)
+        self.assertRegex(
+            repr(uut),
+            "<NlSectionPosition object\\(file='.*None', line=None, "
+            'column=None\\) at 0x[0-9a-fA-F]+>')
+        self.assertEqual(str(uut), 'None')
+
+        uut = NlSectionPosition('filename', 3, 2)
+        self.assertEqual(str(uut), 'filename:3:2')
+
+    # Set the setter and getter properties
+    def test_properties(self):
+        uut = NlSectionPosition('file', 1, 2)
+        self.assertEqual(uut.line, 1)
+        self.assertEqual(uut.column, 2)
+
+        uut.line = 5
+        uut.column = None
+        self.assertEqual(uut.line, 5)
+        self.assertEqual(uut.column, None)

From 8f1a37cd921c6e5370fddd669221c5f740723ff7 Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Wed, 21 Aug 2019 16:32:12 +0530
Subject: [PATCH 03/19] Parser.py: Add Parser.py

This PR adds the Parser class.

Parsers are used to seperate a nested language file into
various nested language sections. Parser eats up the files
and spits out a list of NlSection objects that is used to
identify which part of the file has which language.

This is a Base Class for all the parsers that would henceforth
parse nested language files.
---
 coalib/nestedlib/parsers/Parser.py    | 45 +++++++++++++++++++++++++++
 tests/nestedlib/parsers/ParserTest.py | 41 ++++++++++++++++++++++++
 2 files changed, 86 insertions(+)
 create mode 100755 coalib/nestedlib/parsers/Parser.py
 create mode 100755 tests/nestedlib/parsers/ParserTest.py

diff --git a/coalib/nestedlib/parsers/Parser.py b/coalib/nestedlib/parsers/Parser.py
new file mode 100755
index 000000000..2a3c8aefb
--- /dev/null
+++ b/coalib/nestedlib/parsers/Parser.py
@@ -0,0 +1,45 @@
+from coalib.nestedlib.NlSection import NlSection
+from coalib.io.File import File
+
+
+class Parser():
+
+    def parse(self, filename):
+        """
+        Return a list of nl_sections.
+
+        :param file_contents: The contents of the original nested file
+        """
+        raise NotImplementedError
+
+
+# The following methods are the utilities for the parsers.
+
+def get_file(filename):
+    """
+    Get the contents of the file mentioned in filename.
+    Returns a tuple of all lines present in the file
+    """
+    file = File(filename)
+    return file.lines
+
+
+def create_nl_section(file,
+                      index,
+                      language,
+                      start_line=None,
+                      start_column=None,
+                      end_line=None,
+                      end_column=None,):
+    """
+    Create a NlSection Object from the values.
+    Returns the NlSection object
+    """
+    return NlSection.from_values(file=file,
+                                 index=index,
+                                 language=language,
+                                 start_line=start_line,
+                                 start_column=start_column,
+                                 end_line=end_line,
+                                 end_column=end_column,
+                                 )
diff --git a/tests/nestedlib/parsers/ParserTest.py b/tests/nestedlib/parsers/ParserTest.py
new file mode 100755
index 000000000..1323698c5
--- /dev/null
+++ b/tests/nestedlib/parsers/ParserTest.py
@@ -0,0 +1,41 @@
+import os
+import unittest
+from coalib.io.File import File
+
+
+from coalib.nestedlib.parsers.Parser import Parser, get_file, create_nl_section
+from coalib.nestedlib.NlSection import NlSection
+
+TEST_FILE_DIR = os.path.join(os.path.split(__file__)[0],
+                             'file_test_files')
+
+
+class ParserTest(unittest.TestCase):
+
+    def test_api(self):
+        test_object = Parser()
+
+        with self.assertRaises(NotImplementedError):
+            test_object.parse('A')
+
+    def test_get_file(self):
+        file_test_dir = TEST_FILE_DIR
+        self.test_file_path = os.path.join(file_test_dir, 'test1.txt')
+        self.test_file = File(self.test_file_path)
+
+        uut = get_file(self.test_file_path)
+        self.assertEqual(self.test_file.lines, uut)
+
+    def test_create_nl_section(self):
+        self.nl_section = NlSection.from_values(file='A', index=1,
+                                                language='python', start_line=2,
+                                                end_line=4)
+
+        uut = create_nl_section(file='A', index=1, language='python',
+                                start_line=2, end_line=4)
+
+        self.assertEqual(self.nl_section.file, uut.file)
+        self.assertEqual(self.nl_section.index, uut.index)
+        self.assertEqual(self.nl_section.language, uut.language)
+        self.assertEqual(self.nl_section.start, uut.start)
+        self.assertEqual(self.nl_section.end, uut.end)

From 5780a6345ad6e85ed5ad37ec3e11ff939b2ad4f3 Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Wed, 21 Aug 2019 16:37:25 +0530
Subject: [PATCH 04/19] PyJinjaParser.py: Add PyJinjaParser

This PR adds an Parser that can parse through a nested
language file which is made up of the combination of
python and jinja2 and gives out a list of NlSection
Objects.
---
 coalib/nestedlib/parsers/PyJinjaParser.py     | 560 ++++++++++++++++++
 tests/nestedlib/parsers/PyJinjaParserTest.py  | 293 +++++++++
 .../file_test_files/test-jinja-py.py.jj2.txt  |   6 +
 .../file_test_files/test-jinja2-py.jj2.txt    |   6 +
 .../file_test_files/test-setup-py.py.jj2.txt  | 368 ++++++++++++
 .../parsers/file_test_files/test1.txt         |   3 +
 .../coala-setup-parser-output.txt             | 211 +++++++
 7 files changed, 1447 insertions(+)
 create mode 100755 coalib/nestedlib/parsers/PyJinjaParser.py
 create mode 100755 tests/nestedlib/parsers/PyJinjaParserTest.py
 create mode 100755 tests/nestedlib/parsers/file_test_files/test-jinja-py.py.jj2.txt
 create mode 100755 tests/nestedlib/parsers/file_test_files/test-jinja2-py.jj2.txt
 create mode 100755 tests/nestedlib/parsers/file_test_files/test-setup-py.py.jj2.txt
 create mode 100755 tests/nestedlib/parsers/file_test_files/test1.txt
 create mode 100755 tests/nestedlib/parsers/file_test_output/coala-setup-parser-output.txt

diff --git a/coalib/nestedlib/parsers/PyJinjaParser.py b/coalib/nestedlib/parsers/PyJinjaParser.py
new file mode 100755
index 000000000..630028e66
--- /dev/null
+++ b/coalib/nestedlib/parsers/PyJinjaParser.py
@@ -0,0 +1,560 @@
+from coalib.nestedlib.parsers.Parser import Parser, create_nl_section, get_file
+import regex as re
+
+# `regex` module is used instead of `re` since `re` does not have the
+# capability to compile regex statements that have the same group names.
+
+
+class PyJinjaParser(Parser):
+
+    JINJA_STATEMENT_PATTERN = (
+        r'(?P<open>{%[+-]?)(?P<content>.*?)(?P<close>[+-]?%})')
+    JINJA_VAR_PATTERN = (
+        r'(?P<open>{{)(?P<content>.*?)(?P<close>}})')
+    JINJA_RE = re.compile(
+        '|'.join([JINJA_STATEMENT_PATTERN, JINJA_VAR_PATTERN]))
+
+    append_prev_section = True
+    """
+    append_prev_section is a boolean variable.
+
+    This determines if a new section needs to be created for the current line or
+    if it can be appended to the previous nl_sections.
+
+    This is needed because we do not want to mix the contents from a mixed lang
+    line and a pure line. This helps in better maintainability of nl_sections.
+    """
+
+    def new_nl_section(self, file, language, nl_sections=None, start_line=None,
+                       start_column=None, end_line=None, end_column=None):
+        """
+        Create a new nl_section.
+
+        :param file:         The name of the original nested languges file.
+        :param language:     The language of the current line.
+        :param nl_sections:  The list of nested languages sections present in
+                             file
+        :param start_line:   The line number where the Nested Language Section
+                             starts. The first line is 1.
+        :param start_column: The column number where the Nested Language
+                             Section
+                             starts. The first column is 1.
+        :param end_line:     The line number where the Nested Language Section
+                             end.
+        :param end_column:   The column number where the Nested Language Section
+                             starts.
+        """
+        prev_nl_section = nl_sections[-1] if nl_sections else None
+        index = 1 if not prev_nl_section else (prev_nl_section.index + 1)
+        nl_section = create_nl_section(file=file,
+                                       index=index,
+                                       language=language,
+                                       start_line=start_line,
+                                       start_column=start_column,
+                                       end_line=end_line,
+                                       end_column=end_column)
+
+        nl_sections.append(nl_section)
+        return nl_sections
+
+    def update_nl_section(self, nl_sections=None, end_line=None,
+                          end_column=None):
+        """
+        Update the end line and the end column of the last Nested Language
+        Section present in nl_sections.
+
+        This happens when the line above the current line has the same language
+        as that of current line. Instead of creating a new section for the
+        current line, we append it to the last nl_section present in
+        nl_sections.
+
+        :param nl_sections:  The list of nested languages sections present in
+                             file
+        :param end_line:     The line number where the Nested Language Section
+                             end.
+        :param end_column:   The column number where the Nested Language Section
+                             starts.
+        """
+        prev_nl_section = nl_sections[-1]
+        prev_nl_section.end.line = end_line
+        prev_nl_section.end.column = end_column
+        prev_nl_section.linted_end.line = end_line
+        prev_nl_section.linted_end.column = end_column
+        return nl_sections
+
+    def pure_line_sections(self, file, line, nl_sections=None, language=None,
+                           line_number=None, start_column=None,
+                           end_column=None):
+        """
+        Create sections from a pure line.
+
+        Example of Pure Lines are:
+        >> "{% for x in y %}"
+        >> "{% set var1 = value1 %}"
+        >> "print("Bye Bye")"
+
+        If the line is made up of only one language. There are two things that
+        can be done.
+        1. If the language of the last nl_section is different than the lang of
+           the current line, then create a new nl_section for the current line.
+        2. If the language of the last nl_section is same as that of the current
+           line, update the end_line and end_column values of the last
+           nl_section. This is equivalent to appending the current line to the
+           previous nl_section.
+
+        :param file:         The name of the original nested languges file.
+        :param line:         The current line.
+        :param nl_sections:  The list of nested languages sections present in
+                             file
+        :param language:     The language of the current line.
+        :param line_number:  The line number of the current line correspondnig
+                             to the original Nested language file.
+        :param start_column: The column number where the Nested Language Section
+                             starts. The first column is 1.
+        :param end_column:   The column number where the Nested Language Section
+                             starts.
+        """
+        prev_nl_section = nl_sections[-1] if nl_sections else None
+        if((not prev_nl_section or
+                not (prev_nl_section.language == language))
+                or not self.append_prev_section):
+            """
+            Create a new nl_section if there are no nl_section present
+            or if the language of the previous section do not match
+            with the language of the current line.
+            """
+            nl_sections = self.new_nl_section(file=file,
+                                              language=language,
+                                              nl_sections=nl_sections,
+                                              start_line=line_number,
+                                              start_column=start_column,
+                                              end_line=line_number,
+                                              end_column=end_column)
+
+            self.append_prev_section = True
+        else:
+            """
+            If the language of pervious section and the current line are
+            same, append current line to the previous section. You
+            do that by updating the `end` attribute of the previous
+            nl section
+            """
+            nl_sections = self.update_nl_section(nl_sections, line_number,
+                                                 len(line)-1)
+        return nl_sections
+
+    def check_pure_jinja_line(self, line):
+        """
+        Check if the line is pure Jinja.
+
+        Update the values of self.append_prev_section and PURE_JINJA_LINE
+        accordingly. To check if a line is pure jinja2, check if the content
+        before and after the match object is white space. If it is, then it is
+        purely jinja2
+
+        :param line:         The current line.
+        """
+        pure_jinja_line = False
+
+        start_column = 0
+        end_column = len(line)-1
+        match = self.JINJA_RE.search(line)
+        num_jinja_elem = len(re.findall(self.JINJA_RE, line))
+
+        if (num_jinja_elem > 1):
+            return pure_jinja_line
+
+        elif match.start() == start_column and match.end() == end_column:
+            pure_jinja_line = True
+            return pure_jinja_line
+
+        elif match.start() == start_column and match.end() < end_column:
+            content_after_match = line[match.end():end_column+1]
+            if (content_after_match.isspace()):
+                pure_jinja_line = True
+            return pure_jinja_line
+
+        elif match.start() > start_column and match.end() == end_column:
+            content_before_match = line[0:match.start()]
+            if (content_before_match.isspace()):
+                pure_jinja_line = True
+            return pure_jinja_line
+
+        else:
+            # Check if match.start() > start_column and match.end() < end_column
+            content_before_match = line[0:match.start()]
+            content_after_match = line[match.end():end_column+1]
+            if content_before_match.isspace() and content_after_match.isspace():
+                pure_jinja_line = True
+            return pure_jinja_line
+
+    def segre_mixed_line(self, file, line, nl_sections, line_number=None,
+                         match=None, cursor=None):
+        """
+        Segregate the line made of up mixed languages into Nested Language
+        sections.
+
+        A line that is made up of both Jinja and Python are called as mixed
+        language lines.
+        Examples of mixed language lines are:
+        >> "{% endif %} x = 40 {{ }}"
+        >> "y = {{ var }} if x > 40 else {{ var2 }}"
+        >> "{% set x = thanos %} print("He rocks")"
+
+        Also, due to the way parser works it detects a pure jinja2 line with
+        white spaces infront of it as a mixed language line. In order to
+        overcome this we check if the characters before the first match of the
+        jinja2 element are whitespaces. If it is - we create a pure jinja2 line
+        section or append it to the previous nl_section if the language is same.
+
+        :param file:         The name of the original nested languges file.
+        :param line:         The current line.
+        :param nl_sections:  The list of nested languages sections present in
+                             file
+        :param line_number:  The line number of the current line correspondnig
+                             to the original Nested language file.
+        :param match:        The match object which detected the Jinja element.
+        :param cursor:       The cursor points to the next character in the
+                             line that has to be read.
+
+        """
+        content_before_match = line[cursor:match.start()]
+
+        if (content_before_match.isspace()):
+
+            nl_sections = self.pure_line_sections(file=file,
+                                                  line=line,
+                                                  nl_sections=nl_sections,
+                                                  language='jinja2',
+                                                  line_number=line_number,
+                                                  start_column=cursor+1,
+                                                  end_column=match.end())
+
+        else:
+            # Python Section
+            nl_sections = self.new_nl_section(file=file,
+                                              language='python',
+                                              nl_sections=nl_sections,
+                                              start_line=line_number,
+                                              start_column=cursor+1,
+                                              end_line=line_number,
+                                              end_column=match.start())
+
+            # Jinja Section
+            nl_sections = self.new_nl_section(file=file,
+                                              language='jinja2',
+                                              nl_sections=nl_sections,
+                                              start_line=line_number,
+                                              start_column=match.start()+1,
+                                              end_line=line_number,
+                                              end_column=match.end())
+
+        return nl_sections
+
+    def parse_line(self, line, nl_sections=None, line_number=None,
+                   file=None):
+        """
+        Parse the current line and returns a list of nl_section.
+
+        :param file:         The name of the original nested languges file.
+        :param line:         The current line.
+        :param nl_sections:  The list of nested languages sections present in
+                             file
+        :param line_number:  The line number of the current line correspondnig
+                             to the original Nested language file.
+        """
+        line_number = line_number if (line_number) else 1
+
+        start_column = 0
+
+        # len(line) also includes the newline character - hence we subtract one
+        end_column = len(line) - 1
+
+        # The cursor points to the next character in the line that has to be
+        # read. The cursor is needed when we have a mixed language line. This
+        # keeps track of all the jinja2 elements that have been read on the
+        # current line.
+        cursor = start_column
+
+        # Check the line is empty.
+        # If the line is empty and there is a nl_section present before it
+        # append the line to it. Else create a new nl_section of any language
+        # it does not matter
+        if not line.strip():
+            prev_nl_section = nl_sections[-1] if nl_sections else None
+            if not prev_nl_section:
+                nl_sections = self.new_nl_section(file=file,
+                                                  language='jinja2',
+                                                  nl_sections=nl_sections,
+                                                  start_line=line_number,
+                                                  start_column=1,
+                                                  end_column=end_column)
+            else:
+                nl_sections = self.update_nl_section(nl_sections, line_number,
+                                                     1)
+            return nl_sections
+
+        # Check if the line has any Jinja elements. If not it's pure Python
+        if not self.JINJA_RE.search(line):
+            lang_cur_line = 'python'
+
+            self.pure_line_sections(file=file,
+                                    line=line,
+                                    nl_sections=nl_sections,
+                                    language=lang_cur_line,
+                                    line_number=line_number,
+                                    start_column=cursor+1,
+                                    end_column=end_column)
+
+            return nl_sections
+
+        else:
+            """
+            If the line contains Jinja Elements. There can be three cases:
+            1. Pure Jinja Line
+            2. Combination of Jinja and Python
+
+            If it's a pure Jinja Line, we create a new nl_section if the
+            language of previous section is different than the current
+            section. If the language is same, we directly append this line
+            to the previous nl_section.
+
+            If it's a combination of Jinja and Python. We create a seperate
+            nl_sections for each of element.
+
+            >> line = '{{ var }} = print("Bye Bye")'
+            >> nl_sections = parse_line(line, nl_sections = [])
+            ['test.py: 1 : jinja2  : L1 C1  : L1 C9  : L1 C1  : L1 C9',
+            'test.py: 2 : python : L1 C10 : L1 C28 : L1 C10 : L1 C28'
+            ]
+            """
+
+            """
+            Get a list of all Jinja Elements. And on the basis of the start
+            column and end column of the Jinja Element we make the sections
+            accordingly.
+            """
+            match_objects = self.JINJA_RE.finditer(line)
+
+            """
+            If it's a mixed language line, do not append it to previous
+            section.
+
+            If the line has only one Jinja Element, it can still be a mixed
+            language line. So we check if the span values of the match object
+            is equal to the start_column which is zero and end_column which
+            is len(line) - 1. If it is then it's a Pure Jinja Line.
+            """
+            pure_jinja_line = self.check_pure_jinja_line(line)
+
+            if not pure_jinja_line:
+                self.append_prev_section = False
+
+            for match in match_objects:
+                lang_cur_line = 'jinja2'
+
+                if(match.start() == cursor and match.end() == end_column):
+                    """
+                    If the first match object spans the entire line that means
+                    that the line is a Pure jinja2 line.
+                    Eg:
+                    >> line = "{% set x = 0 %}"
+                    """
+                    nl_sections = self.pure_line_sections(
+                                                        file=file,
+                                                        line=line,
+                                                        nl_sections=nl_sections,
+                                                        language=lang_cur_line,
+                                                        line_number=line_number,
+                                                        start_column=cursor+1,
+                                                        end_column=match.end())
+
+                    cursor = match.end()
+
+                elif(match.start() == cursor and match.end() < end_column):
+                    """
+                    If the Jinja elements starts at the start of line, but it
+                    ends at a position less than the end_column of the line.
+                    Make a Jinja Section of the element and shift the cursor
+                    to one character after the end of the jinja2 element/
+
+                    Assume cursor is 0 and end_column is 24. As you see below
+                    the first jinja2 element starts at cursor i.e 0 but the it
+                    end at 14 which is less than the end column.
+
+                    >> line = "{% set x = 0 %} x = 40  {{ var1 }}"
+                    """
+                    nl_sections = self.new_nl_section(file=file,
+                                                      language='jinja2',
+                                                      nl_sections=nl_sections,
+                                                      start_line=line_number,
+                                                      start_column=cursor+1,
+                                                      end_line=line_number,
+                                                      end_column=match.end())
+                    cursor = match.end()
+
+                elif(match.start() > cursor and match.end() == end_column):
+                    """
+                    If the match object starts at a column which is not the
+                    starting of the line, that mean that it has some content
+                    before it.
+
+                    The content before the match object can either be a
+                    collection of spaces or python code.
+
+                    If it's spaces then that means that the entire line is pure
+                    jinja2 and we need to make one section.
+
+                    Else we make two sections, one for python that includes the
+                    text before the match object and another for jinja2.
+
+                    >> line = "x = 40 {% set x = 0 %}"
+
+                    Assume the cursor is zero and end_column is `len(line) - 1`.
+                    The Jinja element `{% set x = 0 %}` starts at a column
+                    greater than cursor but ends at the end_column.
+                    """
+
+                    nl_sections = self.segre_mixed_line(file=file,
+                                                        nl_sections=nl_sections,
+                                                        line=line,
+                                                        line_number=line_number,
+                                                        match=match,
+                                                        cursor=cursor)
+                    cursor = match.end()
+
+                else:
+                    """
+                    Check:
+                    if match.start() > cursor and match.end() < end_column.
+
+                    The match object starts at a column which is greater than
+                    the cursor and end at a column less than the end_column.
+
+
+
+                    This deals with the Jinja elements present somewhere in the
+                    middle of the line.
+                    >> line = "x = 40 {% set x = 0 %} {{ var1 }}"
+
+                    Assume the cursor is zero and end_column is `len(line) - 1`.
+                    The Jinja element `{% set x = 0 %}` represents this
+                    scenario.
+                    """
+                    nl_sections = self.segre_mixed_line(file=file,
+                                                        nl_sections=nl_sections,
+                                                        line=line,
+                                                        line_number=line_number,
+                                                        match=match,
+                                                        cursor=cursor)
+
+                    cursor = match.end()
+
+                self.append_prev_section = True
+
+            if not cursor == end_column:
+                """
+                If the cursor is not equal to the length of line that means we
+                have some python code after all the Jinja elements on the line.
+                i.e present on the last of line.
+
+                eg: "x = 14 {% set y = 10 %} z = 30 "
+
+                There might also be the condition where there are spaces left at
+                the end of the line. If it is present. Then add those to the
+                previous jinja2 section.
+
+                If we run our parse, the code until above would only have made
+                nl_sections until the {% set y = 10 %}. There was no nl_section
+                made for z = 30. That's why we make the nl_section for that.
+                """
+
+                content_after_match = line[cursor:end_column+1]
+
+                # If we have only one Jinja Element and after that we have space
+                # the line will be considered as pure
+                if (content_after_match.isspace()):
+
+                    nl_sections = self.update_nl_section(
+                                                        nl_sections=nl_sections,
+                                                        end_line=line_number,
+                                                        end_column=len(line)-1)
+
+                else:
+                    nl_sections = self.new_nl_section(file=file,
+                                                      language='python',
+                                                      nl_sections=nl_sections,
+                                                      start_line=line_number,
+                                                      start_column=cursor+1,
+                                                      end_line=line_number,
+                                                      end_column=len(line)-1)
+
+            # If the present line was not a pure Jinja line, the next line
+            # should not be appended to the current line.
+            if not pure_jinja_line:
+                self.append_prev_section = False
+
+        return nl_sections
+
+    def make_nl_sections(self, file_contents, filename):
+        nl_sections = []
+        line_number = 0
+
+        for line in file_contents:
+            line_number += 1
+            nl_sections = self.parse_line(line,
+                                          line_number=line_number,
+                                          nl_sections=nl_sections,
+                                          file=filename)
+
+        return nl_sections
+
+    def parse(self, filename):
+        """
+        Return a list of nl_sections.
+
+        :param file_contents: The contents of the original nested file.
+
+        >>> from coalib.nestedlib.parsers.PyJinjaParser import PyJinjaParser
+        >>> file_contents = ("for x in y:\\n",
+        ...                  "{% if x is True %}\\n",
+        ...                  "\\t{% set var3 = value3 %}\\n",
+        ...                  "{% elif %}\\n",
+        ...                  "\\t\\t{{ var }} = print('Bye Bye')\\n")
+
+        >>> parser = PyJinjaParser()
+        >>> nl_sections = parser.make_nl_sections(file_contents, 'test.py')
+
+        >>> str(nl_sections[0])
+        '...test.py: 1: python: L1 C1: L1 C11: L1 C1: L1 C11'
+
+        >>> str(nl_sections[1])
+        '...test.py: 2: jinja2: L2 C1: L4 C10: L2 C1: L4 C10'
+
+        >>> str(nl_sections[2])
+        '...test.py: 3: jinja2: L5 C1: L5 C11: L5 C1: L5 C11'
+
+        >>> str(nl_sections[3])
+        '...test.py: 4: python: L5 C12: L5 C30: L5 C12: L5 C30'
+
+        The details of the ouput from the parser is as follows:
+
+        The first column    - The name of the file the original nested language
+                              file.
+        The second column   - The language of the nl_section
+        The third column    - The index of the section.
+        The fourth column   - The start of that section in the original nested
+                              file.
+        The fifth column    - The end of that section in the original nested
+                              file.
+        The sixth column    - The start of that section in the original nested
+                              file.
+        The seventh column  - The start of that section in the original nested
+                              file.
+        """
+        # A list to store all the nl_section in the file
+
+        file_contents = get_file(filename)
+
+        nl_sections = self.make_nl_sections(file_contents, filename)
+        return nl_sections
diff --git a/tests/nestedlib/parsers/PyJinjaParserTest.py b/tests/nestedlib/parsers/PyJinjaParserTest.py
new file mode 100755
index 000000000..bb0add584
--- /dev/null
+++ b/tests/nestedlib/parsers/PyJinjaParserTest.py
@@ -0,0 +1,293 @@
+import os
+import unittest
+from os.path import abspath
+from coalib.io.File import File
+
+from coalib.nestedlib.parsers.PyJinjaParser import PyJinjaParser
+TEST_FILE_DIR = os.path.join(os.path.split(__file__)[0], 'file_test_files')
+TEST_OUTPUT_DIR = os.path.join(os.path.split(__file__)[0], 'file_test_output')
+
+
+class PyJinjaParserTest(unittest.TestCase):
+
+    def setUp(self):
+        self.file_test_dir = TEST_FILE_DIR
+        self.file_test_output = TEST_OUTPUT_DIR
+        self.test_filename1 = 'test-jinja-py.py.jj2.txt'
+        self.test_file1_path = os.path.join(self.file_test_dir,
+                                            self.test_filename1)
+        self.abs_test_file1_path = abspath(self.test_file1_path)
+
+        self.test_file1 = File(self.abs_test_file1_path)
+        self.test_file1_lines = (self.test_file1).lines
+
+        self.parser = PyJinjaParser()
+
+    def test_parse(self):
+        uut_sections = self.parser.parse(self.abs_test_file1_path)
+        uut_section_list = []
+
+        nl_section_list = [
+            self.abs_test_file1_path + ': 1: python: L1 C1: L1 C11:' +
+            ' L1 C1: L1 C11',
+            self.abs_test_file1_path + ': 2: jinja2: L2 C1: L5 C10:' +
+            ' L2 C1: L5 C10',
+            self.abs_test_file1_path + ': 3: jinja2: L6 C1: L6 C13:' +
+            ' L6 C1: L6 C13',
+            self.abs_test_file1_path + ': 4: python: L6 C14: L6 C32:' +
+            ' L6 C14: L6 C32'
+        ]
+
+        for nl_section in uut_sections:
+            uut_section_list.append(str(nl_section))
+
+        self.assertEqual(nl_section_list, uut_section_list)
+
+    def test_parse_line_1_pure_python(self):
+        # Pure Python Line
+        # line = 'for x in y:'
+        test_file_line1 = self.test_file1.lines[0]
+        uut_nl_section = self.parser.parse_line(line=test_file_line1,
+                                                nl_sections=[],
+                                                line_number=1,
+                                                file=self.test_filename1)
+
+        expected_nl_section_str = ('.*test-jinja-py.py.jj2.txt' +
+                                   ': 1: python: L1 C1: L1 C11: L1 C1: L1 C11')
+
+        self.assertRegex(str(uut_nl_section[0]), expected_nl_section_str)
+
+    def test_parse_line_2_pure_jinja(self):
+        # Pure Jinja Line
+        # line = '{% if x is True %}'
+        test_file_line1 = self.test_file1.lines[1]
+        uut_nl_section = self.parser.parse_line(line=test_file_line1,
+                                                nl_sections=[],
+                                                line_number=2,
+                                                file=self.test_filename1)
+
+        expected_nl_section_str = ('.*test-jinja-py.py.jj2.txt' +
+                                   ': 1: jinja2: L2 C1: L2 C18: L2 C1: L2 C18')
+
+        self.assertRegex(str(uut_nl_section[0]), expected_nl_section_str)
+
+    def test_parse_line_5_mixed_line(self):
+        # A Line with python and Jinja
+        # line = '    {{ var }} = print("Bye Bye")'
+        test_file_line1 = self.test_file1.lines[5]
+        uut_nl_section = self.parser.parse_line(line=test_file_line1,
+                                                nl_sections=[],
+                                                line_number=5,
+                                                file=self.test_filename1)
+
+        expected_nl_section_1_str = (
+                                    '.*test-jinja-py.py.jj2.txt' +
+                                    ': 1: jinja2: L5 C1: L5 C13: L5 C1: L5 C13'
+                                )
+
+        expected_nl_section_2_str = (
+                                  '.*test-jinja-py.py.jj2.txt' +
+                                  ': 2: python: L5 C14: L5 C32: L5 C14: L5 C32'
+                                  )
+
+        self.assertRegex(str(uut_nl_section[0]), expected_nl_section_1_str)
+        self.assertRegex(str(uut_nl_section[1]), expected_nl_section_2_str)
+
+    def test_parse_line_impure_line_conditions(self):
+
+        # Test condition: match.start() == cursor and match.end() < end_column
+        # line = '{% set x = 12 %} print(x)'
+        line = '{% set x = 12 %} print(x)\n'
+        uut_nl_section = self.parser.parse_line(line=line,
+                                                nl_sections=[],
+                                                line_number=1,
+                                                file=self.test_filename1)
+
+        expected_nl_section_1_str = (
+                                    '.*test-jinja-py.py.jj2.txt' +
+                                    ': 1: jinja2: L1 C1: L1 C16: L1 C1: L1 C16')
+
+        expected_nl_section_2_str = (
+                                '.*test-jinja-py.py.jj2.txt' +
+                                ': 2: python: L1 C17: L1 C25: L1 C17: L1 C25'
+                                )
+
+        self.assertRegex(str(uut_nl_section[0]), expected_nl_section_1_str)
+        self.assertRegex(str(uut_nl_section[1]), expected_nl_section_2_str)
+
+        # Test condition: match.start() > cursor and match.end() == end_column
+        # line = '   {% set x = 12 %} print(x)'
+        line = '   {% set x = 12 %} print(x)\n'
+        uut_nl_section = self.parser.parse_line(line=line,
+                                                nl_sections=[],
+                                                line_number=1,
+                                                file=self.test_filename1)
+
+        expected_nl_section_1_str = (
+                                    '.*test-jinja-py.py.jj2.txt' +
+                                    ': 1: jinja2: L1 C1: L1 C19: L1 C1: L1 C19')
+
+        expected_nl_section_2_str = (
+                                '.*test-jinja-py.py.jj2.txt' +
+                                ': 2: python: L1 C20: L1 C28: L1 C20: L1 C28')
+
+        self.assertRegex(str(uut_nl_section[0]), expected_nl_section_1_str)
+        self.assertRegex(str(uut_nl_section[1]), expected_nl_section_2_str)
+
+        line = 'print(x) {% set x = 12 %}\n'
+        uut_nl_section = self.parser.parse_line(line=line,
+                                                nl_sections=[],
+                                                line_number=1,
+                                                file=self.test_filename1)
+
+        expected_nl_section_1_str = ('.*test-jinja-py.py.jj2.txt' +
+                                     ': 1: python: L1 C1: L1 C9: L1 C1: L1 C9')
+
+        expected_nl_section_2_str = (
+                                '.*test-jinja-py.py.jj2.txt' +
+                                ': 2: jinja2: L1 C10: L1 C25: L1 C10: L1 C25')
+
+        self.assertRegex(str(uut_nl_section[0]), expected_nl_section_1_str)
+        self.assertRegex(str(uut_nl_section[1]), expected_nl_section_2_str)
+
+    def test_impure_lines_two_jinja_elements(self):
+
+        # Test Contition1: match.start() > cursor and match.end() < end_column
+        # Test Condition2: num_jinja_elem > 1
+        # line = '{% set x = 12 %} print(x) {% if x > 40 %}'
+
+        line = '{% set x = 12 %} print(x) {% if x > 40 %}  print(x)\n'
+        uut_nl_section = self.parser.parse_line(line=line,
+                                                nl_sections=[],
+                                                line_number=1,
+                                                file=self.test_filename1)
+
+        expected_nl_section_1_str = (
+                                    '.*test-jinja-py.py.jj2.txt' +
+                                    ': 1: jinja2: L1 C1: L1 C16: L1 C1: L1 C16')
+
+        expected_nl_section_2_str = (
+                                '.*test-jinja-py.py.jj2.txt' +
+                                ': 2: python: L1 C17: L1 C26: L1 C17: L1 C26')
+
+        expected_nl_section_3_str = (
+                                '.*test-jinja-py.py.jj2.txt' +
+                                ': 3: jinja2: L1 C27: L1 C41: L1 C27: L1 C41')
+
+        expected_nl_section_4_str = (
+                                '.*test-jinja-py.py.jj2.txt' +
+                                ': 4: python: L1 C42: L1 C51: L1 C42: L1 C51')
+
+        self.assertRegex(str(uut_nl_section[0]), expected_nl_section_1_str)
+        self.assertRegex(str(uut_nl_section[1]), expected_nl_section_2_str)
+        self.assertRegex(str(uut_nl_section[2]), expected_nl_section_3_str)
+        self.assertRegex(str(uut_nl_section[3]), expected_nl_section_4_str)
+
+    def test_parse_line_spaces_at_end(self):
+
+        # Test condition: if not cursor == end_column and
+        #                                      content_after_match.isspace()
+        # line = '{% set y = 10 %} z = 30   '
+        line = '{% set y = 10 %}   \n'
+        uut_nl_section = self.parser.parse_line(line=line,
+                                                nl_sections=[],
+                                                line_number=1,
+                                                file=self.test_filename1)
+
+        expected_nl_section_1_str = (
+                                    '.*test-jinja-py.py.jj2.txt' +
+                                    ': 1: jinja2: L1 C1: L1 C19: L1 C1: L1 C19')
+
+        self.assertRegex(str(uut_nl_section[0]), expected_nl_section_1_str)
+
+    def test_parse_line_empty_line(self):
+
+        # Test condition: not line.strip()
+        # line = '\n'
+        line = '\n'
+        uut_nl_section = self.parser.parse_line(line=line,
+                                                nl_sections=[],
+                                                line_number=1,
+                                                file=self.test_filename1)
+
+        expected_nl_section_1_str = ('.*test-jinja-py.py.jj2.txt' +
+                                     ': 1: jinja2: L1 C1: L1 C1: L1 C1: L1 C1')
+        self.assertRegex(str(uut_nl_section[0]), expected_nl_section_1_str)
+
+    def test_parse_pure_jinja_white_space_before_after(self):
+
+        # Test Condition: if content_before_match.isspace() and
+        #                      content_after_match.isspace()
+        # If the pure line has spaces before the element and after the element
+        # line = '    {{ var }}    \n'
+
+        line = '    {{ var }}    \n'
+        uut_nl_section = self.parser.parse_line(line=line,
+                                                nl_sections=[],
+                                                line_number=1,
+                                                file=self.test_filename1)
+
+        expected_nl_section_1_str = (
+                                    '.*test-jinja-py.py.jj2.txt' +
+                                    ': 1: jinja2: L1 C1: L1 C17: L1 C1: L1 C17')
+        self.assertRegex(str(uut_nl_section[0]), expected_nl_section_1_str)
+
+    def test_coala_setup_template(self):
+
+        # Test the setup template of coala present in the moban repository
+        # The expected output of the parser is saved in another file.
+
+        test_filename = 'test-setup-py.py.jj2.txt'
+        test_file_path = os.path.join(self.file_test_dir, test_filename)
+        abs_test_file_path = abspath(test_file_path)
+
+        test_output_filename = 'coala-setup-parser-output.txt'
+        test_file_ouput_path = os.path.join(self.file_test_output,
+                                            test_output_filename)
+        abs_test_file_output_path = abspath(test_file_ouput_path)
+        test_ouput_file = File(abs_test_file_output_path)
+
+        uut_sections = self.parser.parse(abs_test_file_path)
+        nl_section_string = ''
+        expected_string = ''
+
+        for nl_section in uut_sections:
+            nl_section_string += (str(nl_section)+'\n')
+
+        for line in test_ouput_file.lines:
+            expected_string += (abs_test_file_path + line)
+
+        self.assertEqual(nl_section_string, expected_string)
+
+    def test_coala_setup_template_output(self):
+
+        # Generates text using the values generated by the parser
+        # Check if the generated text is equal to the original file
+
+        test_filename = 'test-setup-py.py.jj2.txt'
+        test_file_path = os.path.join(self.file_test_dir, test_filename)
+        abs_test_file_path = abspath(test_file_path)
+
+        original_file = File(abs_test_file_path)
+        original_file_content = original_file.string
+
+        uut_sections = self.parser.parse(abs_test_file_path)
+        generated_file_contents = ''
+
+        for nl_section in uut_sections:
+
+            start_line = nl_section.start.line
+            start_column = nl_section.start.column
+            end_line = nl_section.end.line
+            end_column = nl_section.end.column
+
+            for line_nr in range(start_line, end_line+1):
+                if (line_nr == end_line and line_nr == start_line):
+                    generated_file_contents += (
+                        original_file[line_nr-1][start_column-1:end_column])
+                    if end_column == len(original_file[line_nr-1]) - 1:
+                        generated_file_contents += '\n'
+                else:
+                    generated_file_contents += original_file[line_nr-1][:]
+
+        self.assertEqual(original_file_content, generated_file_contents)
diff --git a/tests/nestedlib/parsers/file_test_files/test-jinja-py.py.jj2.txt b/tests/nestedlib/parsers/file_test_files/test-jinja-py.py.jj2.txt
new file mode 100755
index 000000000..a34577662
--- /dev/null
+++ b/tests/nestedlib/parsers/file_test_files/test-jinja-py.py.jj2.txt
@@ -0,0 +1,6 @@
+for x in y:
+{% if x is True %}
+    {% set var3 = value3 %}
+    
+{% elif %}
+    {{ var }} = sum_square(x1*2)
\ No newline at end of file
diff --git a/tests/nestedlib/parsers/file_test_files/test-jinja2-py.jj2.txt b/tests/nestedlib/parsers/file_test_files/test-jinja2-py.jj2.txt
new file mode 100755
index 000000000..72d2d63cc
--- /dev/null
+++ b/tests/nestedlib/parsers/file_test_files/test-jinja2-py.jj2.txt
@@ -0,0 +1,6 @@
+for x in y:
+{% if x is True %}
+    {% set var3 = value3 %}
+    
+{% elif %}
+    {{ var }} = sum_square(x1*2) {{ y }}  x {{ x }}
\ No newline at end of file
diff --git a/tests/nestedlib/parsers/file_test_files/test-setup-py.py.jj2.txt b/tests/nestedlib/parsers/file_test_files/test-setup-py.py.jj2.txt
new file mode 100755
index 000000000..f0df6ed7c
--- /dev/null
+++ b/tests/nestedlib/parsers/file_test_files/test-setup-py.py.jj2.txt
@@ -0,0 +1,368 @@
+{% if not scm_host %}
+{% set scm_host = 'github.com' %}
+{% endif %}
+{% block shebang %}
+#!/usr/bin/env python3
+{% endblock %}
+{% set min_python_version = min_python_version|default('2.6') %}
+{% set min_python_version = min_python_version.split('.', 2) %}
+
+{% block header %}
+# Template by pypi-mobans
+{% endblock %}
+import codecs
+import locale
+import os
+import platform
+import sys
+from shutil import rmtree
+{% if external_module_library %}
+from distutils.core import setup, Extension
+{% else %}
+
+from setuptools import Command, find_packages, setup
+
+{%endif%}
+{%block compat_block%}
+PY2 = sys.version_info[0] == 2
+PY26 = PY2 and sys.version_info[1] < 7
+PY33 = sys.version_info < (3, 4)
+{%endblock%}
+
+# Work around mbcs bug in distutils.
+# http://bugs.python.org/issue10945
+# This work around is only if a project supports Python < 3.4
+{% if PY33 %}
+try:
+    codecs.lookup("mbcs")
+except LookupError:
+    ascii = codecs.lookup("ascii")
+    func = lambda name, enc=ascii: {True: enc}.get(name=="mbcs")
+    codecs.register(func)
+{% endif %}
+
+# Work around for locale not being set
+try:
+    lc = locale.getlocale()
+    pf = platform.system()
+    if pf != "Windows" and lc == (None, None):
+        locale.setlocale(locale.LC_ALL, "C.UTF-8")
+except (ValueError, UnicodeError, locale.Error):
+    locale.setlocale(locale.LC_ALL, "en_US.UTF-8")
+
+NAME = "{{name}}"
+AUTHOR = "{{author}}"
+VERSION = "{{current_version}}"
+EMAIL = "{{contact}}"
+LICENSE = "{{license}}"
+{% if MAINTAINER %}
+MAINTAINER = "{{maintainer}}"
+MAINTAINER_CONTACT = "{{maintainer_contact}}"
+{% endif %}
+{% if command_line_interface or entry_points %}
+ENTRY_POINTS = {
+{% if not entry_points or 'console_scripts' not in entry_points %}
+    "console_scripts": [
+        "{{command_line_interface}} = {{ entry_point }}"
+    ],
+{% endif %}
+{% if entry_points %}
+  {% for group_name, items in entry_points.items() %}
+    "{{group_name}}": [
+      {% if group_name == "console_scripts" and command_line_interface %}
+        "{{command_line_interface}} = {{ entry_point }}",
+      {% endif %}
+      {% for item in items %}
+        "{{item}}",
+      {% endfor %}
+    ],
+  {% endfor %}
+{% endif %}
+}
+{% endif %}
+DESCRIPTION = (
+{% for line in description | split_length(70) %}
+    "{{ line }}"{{ " +" if not loop.last}}
+{% endfor %}
+)
+URL = "https://{{scm_host}}/{{organisation}}/{{name}}"
+DOWNLOAD_URL = "%s/archive/{{release}}.tar.gz" % URL
+FILES = ["README.rst",{%block morefiles %}{%endblock%} "CHANGELOG.rst"]
+{% if self.additional_keywords %}
+{% set additional_keywords = self.additional_keywords() %}
+{% if additional_keywords and not additional_keywords.rstrip().endswith(",") %}
+{% set additional_keywords = additional_keywords.rstrip() + ",\n" %}
+{% endif %}
+{% endif %}
+KEYWORDS = [
+    "python",
+{% for keyword in keywords %}
+    "{{keyword}}",
+{% endfor %}
+    {%block additional_keywords -%}
+    {%endblock%}
+]
+
+CLASSIFIERS = [
+    "Topic :: Software Development :: Libraries",
+    "Programming Language :: Python",
+    "Intended Audience :: Developers",
+    {% if min_python_version <= ["2", "6"] %}
+    "Programming Language :: Python :: 2.6",
+    {%- endif %}
+
+    {% if min_python_version <= ["2", "7"] %}
+    "Programming Language :: Python :: 2.7",
+    {%- endif %}
+
+    {%- if min_python_version[0] == "3" %}
+    "Programming Language :: Python :: 3 :: Only",
+    {%- endif %}
+
+    {% if min_python_version <= ["3","3"] %}
+    "Programming Language :: Python :: 3.3",
+    {%- endif %}
+
+    {% if min_python_version <= ["3","4"] %}
+    "Programming Language :: Python :: 3.4",
+    {%- endif %}
+
+    {% if min_python_version <= ["3","5"] %}
+    "Programming Language :: Python :: 3.5",
+    {%- endif %}
+
+    {% if min_python_version <= ["3","6"] %}
+    "Programming Language :: Python :: 3.6",
+    {% endif %}
+
+    {% if min_python_version <= ["3","7"] %}
+    "Programming Language :: Python :: 3.7",
+    {% endif %}
+
+    {% if min_python_version <= ["3","8"] %}
+    "Programming Language :: Python :: 3.8",
+    {% endif %}
+
+    {%block additional_classifiers%}
+    {%endblock %}
+]
+
+{%macro handle_complex_dependency(complex_one) -%}
+{%set dependency, condition = complex_one.split(";")%}
+{% if condition == 'python_version<"3"'%}
+if PY2:
+{% endif %}
+{% if condition == 'python_version>="3"'%}
+if not PY2:
+{% endif %}
+{% if condition == 'python_version<"2.7"'%}
+if PY26:
+{% endif %}
+{% if condition == 'platform_python_implementation=="PyPy"'%}
+if platform.python_implementation == "PyPy":
+{%endif%}
+    INSTALL_REQUIRES.append('{{dependency}}')
+{%- endmacro %}
+INSTALL_REQUIRES = [
+{% for dependency in dependencies: %}
+  {% if ';' not in dependency and not dependency.startswith('#'): %}
+    {% if '#egg=' in dependency: %}
+      {% set dependency = dependency.split('#egg=') %}
+      {% set repo_link, egg_name = dependency[0], dependency[1] %}
+      {% set repo_link = repo_link.strip() %}
+      {% if '#' in egg_name: %}
+        {% set egg_name = egg_name.split('#')[0].strip() %}
+      {% endif %}
+    "{{[repo_link, egg_name] | join('#egg=')}}",
+    {% elif '#' in dependency: %}
+      {% set dependency = dependency.split('#')[0].strip() %}
+    "{{dependency}}",
+    {% else %}
+    "{{dependency}}",
+    {% endif %}
+  {%   endif %}
+{% endfor %}
+]
+{% block additional_setup_commands %}
+SETUP_COMMANDS = {}
+{% endblock %}
+
+{% for dependency in dependencies: %}
+  {%  if ';' in dependency: %}
+{{handle_complex_dependency(dependency)}}
+  {%   endif %}
+{% endfor %}
+
+{% if external_module_library %}
+PYMODULE = Extension(
+    '{{name}}',
+    sources=[
+{% for source in sources: %}
+        "{{source}}",
+{% endfor %}
+    ],
+    libraries=INSTALL_REQUIRES
+)
+{% else %}
+PACKAGES = find_packages(exclude=["ez_setup", "examples", "tests"])
+{% if extra_dependencies or dependencies: %}
+EXTRAS_REQUIRE = {
+  {% for dependency in extra_dependencies: %}
+     {% for key, value in dependency.items(): %}
+    "{{key}}": {{value}},
+     {% endfor %}
+  {% endfor %}
+}
+{% else: %}
+EXTRAS_REQUIRE = {}
+{% endif %}
+{% endif %}
+# You do not need to read beyond this line
+{% if nowheel %}
+PUBLISH_COMMAND = "{0} setup.py sdist upload -r pypi".format(sys.executable)
+{% else %}
+PUBLISH_COMMAND = "{0} setup.py sdist bdist_wheel upload -r pypi".format(sys.executable)
+{% endif %}
+GS_COMMAND = ("gs {{name}} v{{release}} " +
+              "Find {{release}} in changelog for more details")
+NO_GS_MESSAGE = ("Automatic github release is disabled. " +
+                 "Please install gease to enable it.")
+UPLOAD_FAILED_MSG = (
+    'Upload failed. please run "%s" yourself.' % PUBLISH_COMMAND)
+HERE = os.path.abspath(os.path.dirname(__file__))
+
+
+class PublishCommand(Command):
+    """Support setup.py upload."""
+
+    description = "Build and publish the package on github and pypi"
+    user_options = []
+
+    @staticmethod
+    def status(s):
+        """Prints things in bold."""
+        print("\033[1m{0}\033[0m".format(s))
+
+    def initialize_options(self):
+        pass
+
+    def finalize_options(self):
+        pass
+
+    def run(self):
+        try:
+            self.status("Removing previous builds...")
+            rmtree(os.path.join(HERE, "dist"))
+            rmtree(os.path.join(HERE, "build"))
+            rmtree(os.path.join(HERE, "{{name|replace('-', '_')}}.egg-info"))
+        except OSError:
+            pass
+
+        self.status("Building Source and Wheel (universal) distribution...")
+        run_status = True
+        if has_gease():
+            run_status = os.system(GS_COMMAND) == 0
+        else:
+            self.status(NO_GS_MESSAGE)
+        if run_status:
+            if os.system(PUBLISH_COMMAND) != 0:
+                self.status(UPLOAD_FAILED_MSG % PUBLISH_COMMAND)
+
+        sys.exit()
+
+
+SETUP_COMMANDS.update({
+    "publish": PublishCommand
+})
+
+
+def has_gease():
+    """
+    test if github release command is installed
+
+    visit http://github.com/moremoban/gease for more info
+    """
+    try:
+        import gease  # noqa
+        return True
+    except ImportError:
+        return False
+
+
+def read_files(*files):
+    """Read files into setup"""
+    text = ""
+    for single_file in files:
+        content = read(single_file)
+        text = text + content + "\n"
+    return text
+
+
+def read(afile):
+    """Read a file into setup"""
+    the_relative_file = os.path.join(HERE, afile)
+    with codecs.open(the_relative_file, "r", "utf-8") as opened_file:
+        content = filter_out_test_code(opened_file)
+        content = "".join(list(content))
+        return content
+
+
+def filter_out_test_code(file_handle):
+    found_test_code = False
+    for line in file_handle.readlines():
+        if line.startswith(".. testcode:"):
+            found_test_code = True
+            continue
+        if found_test_code is True:
+            if line.startswith("  "):
+                continue
+            else:
+                empty_line = line.strip()
+                if len(empty_line) == 0:
+                    continue
+                else:
+                    found_test_code = False
+                    yield line
+        else:
+            for keyword in ["|version|", "|today|"]:
+                if keyword in line:
+                    break
+            else:
+                yield line
+
+
+if __name__ == "__main__":
+    setup(
+{% if "tests" is exists %}
+        test_suite="tests",
+{% endif %}
+        name=NAME,
+        author=AUTHOR,
+        version=VERSION,
+        author_email=EMAIL,
+{% if MAINTAINER %}
+        maintainer=MAINTAINER_NAME,
+        maintainer_email=MAINTAINER_EMAIL,
+{% endif %}
+        description=DESCRIPTION,
+        url=URL,
+        download_url=DOWNLOAD_URL,
+        long_description=read_files(*FILES),
+        license=LICENSE,
+        keywords=KEYWORDS,
+{% if external_module_library %}
+        ext_modules=[PYMODULE],
+{% else %}
+        extras_require=EXTRAS_REQUIRE,
+        tests_require=["nose"],
+        install_requires=INSTALL_REQUIRES,
+        packages=PACKAGES,
+        include_package_data=True,
+        zip_safe=False,
+{% if command_line_interface or entry_points %}
+        entry_points=ENTRY_POINTS,
+{% endif %}
+{% endif%}
+        classifiers=CLASSIFIERS,
+        cmdclass=SETUP_COMMANDS
+    )
diff --git a/tests/nestedlib/parsers/file_test_files/test1.txt b/tests/nestedlib/parsers/file_test_files/test1.txt
new file mode 100755
index 000000000..ce97d1592
--- /dev/null
+++ b/tests/nestedlib/parsers/file_test_files/test1.txt
@@ -0,0 +1,3 @@
+This is a test file
+This is line 2
+This is line 3
\ No newline at end of file
diff --git a/tests/nestedlib/parsers/file_test_output/coala-setup-parser-output.txt b/tests/nestedlib/parsers/file_test_output/coala-setup-parser-output.txt
new file mode 100755
index 000000000..c4722d02e
--- /dev/null
+++ b/tests/nestedlib/parsers/file_test_output/coala-setup-parser-output.txt
@@ -0,0 +1,211 @@
+: 1: jinja2: L1 C1: L4 C19: L1 C1: L4 C19
+: 2: python: L5 C1: L5 C22: L5 C1: L5 C22
+: 3: jinja2: L6 C1: L10 C18: L6 C1: L10 C18
+: 4: python: L11 C1: L11 C25: L11 C1: L11 C25
+: 5: jinja2: L12 C1: L12 C14: L12 C1: L12 C14
+: 6: python: L13 C1: L18 C25: L13 C1: L18 C25
+: 7: jinja2: L19 C1: L19 C32: L19 C1: L19 C32
+: 8: python: L20 C1: L20 C43: L20 C1: L20 C43
+: 9: jinja2: L21 C1: L22 C1: L21 C1: L22 C1
+: 10: python: L23 C1: L24 C1: L23 C1: L24 C1
+: 11: jinja2: L25 C1: L26 C22: L25 C1: L26 C22
+: 12: python: L27 C1: L29 C32: L27 C1: L29 C32
+: 13: jinja2: L30 C1: L31 C1: L30 C1: L31 C1
+: 14: python: L32 C1: L34 C61: L32 C1: L34 C61
+: 15: jinja2: L35 C1: L35 C13: L35 C1: L35 C13
+: 16: python: L36 C1: L41 C25: L36 C1: L41 C25
+: 17: jinja2: L42 C1: L43 C1: L42 C1: L43 C1
+: 18: python: L44 C1: L52 C1: L44 C1: L52 C1
+: 19: python: L53 C1: L53 C8: L53 C1: L53 C8
+: 20: jinja2: L53 C9: L53 C16: L53 C9: L53 C16
+: 21: python: L53 C17: L53 C17: L53 C17: L53 C17
+: 22: python: L54 C1: L54 C10: L54 C1: L54 C10
+: 23: jinja2: L54 C11: L54 C20: L54 C11: L54 C20
+: 24: python: L54 C21: L54 C21: L54 C21: L54 C21
+: 25: python: L55 C1: L55 C11: L55 C1: L55 C11
+: 26: jinja2: L55 C12: L55 C30: L55 C12: L55 C30
+: 27: python: L55 C31: L55 C31: L55 C31: L55 C31
+: 28: python: L56 C1: L56 C9: L56 C1: L56 C9
+: 29: jinja2: L56 C10: L56 C20: L56 C10: L56 C20
+: 30: python: L56 C21: L56 C21: L56 C21: L56 C21
+: 31: python: L57 C1: L57 C11: L57 C1: L57 C11
+: 32: jinja2: L57 C12: L57 C22: L57 C12: L57 C22
+: 33: python: L57 C23: L57 C23: L57 C23: L57 C23
+: 34: jinja2: L58 C1: L58 C19: L58 C1: L58 C19
+: 35: python: L59 C1: L59 C14: L59 C1: L59 C14
+: 36: jinja2: L59 C15: L59 C28: L59 C15: L59 C28
+: 37: python: L59 C29: L59 C29: L59 C29: L59 C29
+: 38: python: L60 C1: L60 C22: L60 C1: L60 C22
+: 39: jinja2: L60 C23: L60 C44: L60 C23: L60 C44
+: 40: python: L60 C45: L60 C45: L60 C45: L60 C45
+: 41: jinja2: L61 C1: L62 C47: L61 C1: L62 C47
+: 42: python: L63 C1: L63 C16: L63 C1: L63 C16
+: 43: jinja2: L64 C1: L64 C66: L64 C1: L64 C66
+: 44: python: L65 C1: L65 C24: L65 C1: L65 C24
+: 45: python: L66 C1: L66 C9: L66 C1: L66 C9
+: 46: jinja2: L66 C10: L66 C35: L66 C10: L66 C35
+: 47: python: L66 C36: L66 C38: L66 C36: L66 C38
+: 48: jinja2: L66 C39: L66 C55: L66 C39: L66 C55
+: 49: python: L66 C56: L66 C56: L66 C56: L66 C56
+: 50: python: L67 C1: L67 C6: L67 C1: L67 C6
+: 51: jinja2: L68 C1: L70 C53: L68 C1: L70 C53
+: 52: python: L71 C1: L71 C5: L71 C1: L71 C5
+: 53: jinja2: L71 C6: L71 C19: L71 C6: L71 C19
+: 54: python: L71 C20: L71 C23: L71 C20: L71 C23
+: 55: jinja2: L72 C1: L72 C73: L72 C1: L72 C73
+: 56: python: L73 C1: L73 C9: L73 C1: L73 C9
+: 57: jinja2: L73 C10: L73 C35: L73 C10: L73 C35
+: 58: python: L73 C36: L73 C38: L73 C36: L73 C38
+: 59: jinja2: L73 C39: L73 C55: L73 C39: L73 C55
+: 60: python: L73 C56: L73 C57: L73 C56: L73 C57
+: 61: jinja2: L74 C1: L75 C29: L74 C1: L75 C29
+: 62: python: L76 C1: L76 C9: L76 C1: L76 C9
+: 63: jinja2: L76 C10: L76 C17: L76 C10: L76 C17
+: 64: python: L76 C18: L76 C19: L76 C18: L76 C19
+: 65: jinja2: L77 C1: L77 C18: L77 C1: L77 C18
+: 66: python: L78 C1: L78 C6: L78 C1: L78 C6
+: 67: jinja2: L79 C1: L80 C11: L79 C1: L80 C11
+: 68: python: L81 C1: L81 C1: L81 C1: L81 C1
+: 69: jinja2: L82 C1: L82 C11: L82 C1: L82 C11
+: 70: python: L83 C1: L83 C15: L83 C1: L83 C15
+: 71: jinja2: L84 C1: L84 C48: L84 C1: L84 C48
+: 72: python: L85 C1: L85 C5: L85 C1: L85 C5
+: 73: jinja2: L85 C6: L85 C15: L85 C6: L85 C15
+: 74: python: L85 C16: L85 C16: L85 C16: L85 C16
+: 75: jinja2: L85 C17: L85 C42: L85 C17: L85 C42
+: 76: jinja2: L86 C1: L86 C12: L86 C1: L86 C12
+: 77: python: L87 C1: L87 C1: L87 C1: L87 C1
+: 78: python: L88 C1: L88 C15: L88 C1: L88 C15
+: 79: jinja2: L88 C16: L88 C27: L88 C16: L88 C27
+: 80: python: L88 C28: L88 C28: L88 C28: L88 C28
+: 81: jinja2: L88 C29: L88 C44: L88 C29: L88 C44
+: 82: python: L88 C45: L88 C45: L88 C45: L88 C45
+: 83: jinja2: L88 C46: L88 C53: L88 C46: L88 C53
+: 84: python: L88 C54: L88 C54: L88 C54: L88 C54
+: 85: python: L89 C1: L89 C27: L89 C1: L89 C27
+: 86: jinja2: L89 C28: L89 C38: L89 C28: L89 C38
+: 87: python: L89 C39: L89 C52: L89 C39: L89 C52
+: 88: python: L90 C1: L90 C22: L90 C1: L90 C22
+: 89: jinja2: L90 C23: L90 C42: L90 C23: L90 C42
+: 90: jinja2: L90 C43: L90 C54: L90 C43: L90 C54
+: 91: python: L90 C55: L90 C71: L90 C55: L90 C71
+: 92: jinja2: L91 C1: L96 C11: L91 C1: L96 C11
+: 93: python: L97 C1: L98 C13: L97 C1: L98 C13
+: 94: jinja2: L99 C1: L99 C29: L99 C1: L99 C29
+: 95: python: L100 C1: L100 C5: L100 C1: L100 C5
+: 96: jinja2: L100 C6: L100 C16: L100 C6: L100 C16
+: 97: python: L100 C17: L100 C18: L100 C17: L100 C18
+: 98: jinja2: L101 C1: L103 C16: L101 C1: L103 C16
+: 99: python: L104 C1: L109 C38: L104 C1: L109 C38
+: 100: jinja2: L110 C1: L110 C45: L110 C1: L110 C45
+: 101: python: L111 C1: L111 C44: L111 C1: L111 C44
+: 102: jinja2: L112 C1: L114 C45: L112 C1: L114 C45
+: 103: python: L115 C1: L115 C44: L115 C1: L115 C44
+: 104: jinja2: L116 C1: L118 C42: L116 C1: L118 C42
+: 105: python: L119 C1: L119 C50: L119 C1: L119 C50
+: 106: jinja2: L120 C1: L122 C44: L120 C1: L122 C44
+: 107: python: L123 C1: L123 C44: L123 C1: L123 C44
+: 108: jinja2: L124 C1: L126 C44: L124 C1: L126 C44
+: 109: python: L127 C1: L127 C44: L127 C1: L127 C44
+: 110: jinja2: L128 C1: L130 C44: L128 C1: L130 C44
+: 111: python: L131 C1: L131 C44: L131 C1: L131 C44
+: 112: jinja2: L132 C1: L134 C44: L132 C1: L134 C44
+: 113: python: L135 C1: L135 C44: L135 C1: L135 C44
+: 114: jinja2: L136 C1: L138 C44: L136 C1: L138 C44
+: 115: python: L139 C1: L139 C44: L139 C1: L139 C44
+: 116: jinja2: L140 C1: L142 C44: L140 C1: L142 C44
+: 117: python: L143 C1: L143 C44: L143 C1: L143 C44
+: 118: jinja2: L144 C1: L147 C17: L144 C1: L147 C17
+: 119: python: L148 C1: L149 C1: L148 C1: L149 C1
+: 120: jinja2: L150 C1: L152 C41: L150 C1: L152 C41
+: 121: python: L153 C1: L153 C7: L153 C1: L153 C7
+: 122: jinja2: L154 C1: L155 C42: L154 C1: L155 C42
+: 123: python: L156 C1: L156 C11: L156 C1: L156 C11
+: 124: jinja2: L157 C1: L158 C43: L157 C1: L158 C43
+: 125: python: L159 C1: L159 C8: L159 C1: L159 C8
+: 126: jinja2: L160 C1: L161 C61: L160 C1: L161 C61
+: 127: python: L162 C1: L162 C44: L162 C1: L162 C44
+: 128: jinja2: L163 C1: L163 C9: L163 C1: L163 C9
+: 129: python: L164 C1: L164 C29: L164 C1: L164 C29
+: 130: jinja2: L164 C30: L164 C43: L164 C30: L164 C43
+: 131: python: L164 C44: L164 C45: L164 C44: L164 C45
+: 132: jinja2: L165 C1: L165 C15: L165 C1: L165 C15
+: 133: python: L166 C1: L166 C20: L166 C1: L166 C20
+: 134: jinja2: L167 C1: L175 C17: L167 C1: L175 C17
+: 135: python: L176 C1: L176 C5: L176 C1: L176 C5
+: 136: jinja2: L176 C6: L176 C46: L176 C6: L176 C46
+: 137: python: L176 C47: L176 C48: L176 C47: L176 C48
+: 138: jinja2: L177 C1: L178 C61: L177 C1: L178 C61
+: 139: python: L179 C1: L179 C5: L179 C1: L179 C5
+: 140: jinja2: L179 C6: L179 C19: L179 C6: L179 C19
+: 141: python: L179 C20: L179 C21: L179 C20: L179 C21
+: 142: jinja2: L180 C1: L180 C14: L180 C1: L180 C14
+: 143: python: L181 C1: L181 C5: L181 C1: L181 C5
+: 144: jinja2: L181 C6: L181 C19: L181 C6: L181 C19
+: 145: python: L181 C20: L181 C21: L181 C20: L181 C21
+: 146: jinja2: L182 C1: L184 C12: L182 C1: L184 C12
+: 147: python: L185 C1: L185 C1: L185 C1: L185 C1
+: 148: jinja2: L186 C1: L186 C37: L186 C1: L186 C37
+: 149: python: L187 C1: L187 C19: L187 C1: L187 C19
+: 150: jinja2: L188 C1: L196 C32: L188 C1: L196 C32
+: 151: python: L197 C1: L197 C21: L197 C1: L197 C21
+: 152: python: L198 C1: L198 C5: L198 C1: L198 C5
+: 153: jinja2: L198 C6: L198 C13: L198 C6: L198 C13
+: 154: python: L198 C14: L198 C15: L198 C14: L198 C15
+: 155: python: L199 C1: L199 C13: L199 C1: L199 C13
+: 156: jinja2: L200 C1: L200 C28: L200 C1: L200 C28
+: 157: python: L201 C1: L201 C9: L201 C1: L201 C9
+: 158: jinja2: L201 C10: L201 C19: L201 C10: L201 C19
+: 159: python: L201 C20: L201 C21: L201 C20: L201 C21
+: 160: jinja2: L202 C1: L202 C12: L202 C1: L202 C12
+: 161: python: L203 C1: L205 C1: L203 C1: L205 C1
+: 162: jinja2: L206 C1: L206 C10: L206 C1: L206 C10
+: 163: python: L207 C1: L207 C67: L207 C1: L207 C67
+: 164: jinja2: L208 C1: L208 C44: L208 C1: L208 C44
+: 165: python: L209 C1: L209 C18: L209 C1: L209 C18
+: 166: jinja2: L210 C1: L211 C48: L210 C1: L211 C48
+: 167: python: L212 C1: L212 C5: L212 C1: L212 C5
+: 168: jinja2: L212 C6: L212 C12: L212 C6: L212 C12
+: 169: python: L212 C13: L212 C15: L212 C13: L212 C15
+: 170: jinja2: L212 C16: L212 C24: L212 C16: L212 C24
+: 171: python: L212 C25: L212 C25: L212 C25: L212 C25
+: 172: jinja2: L213 C1: L214 C14: L213 C1: L214 C14
+: 173: python: L215 C1: L215 C1: L215 C1: L215 C1
+: 174: jinja2: L216 C1: L216 C11: L216 C1: L216 C11
+: 175: python: L217 C1: L217 C19: L217 C1: L217 C19
+: 176: jinja2: L218 C1: L219 C11: L218 C1: L219 C11
+: 177: python: L220 C1: L220 C42: L220 C1: L220 C42
+: 178: jinja2: L221 C1: L221 C16: L221 C1: L221 C16
+: 179: python: L222 C1: L222 C76: L222 C1: L222 C76
+: 180: jinja2: L223 C1: L223 C10: L223 C1: L223 C10
+: 181: python: L224 C1: L224 C88: L224 C1: L224 C88
+: 182: jinja2: L225 C1: L225 C11: L225 C1: L225 C11
+: 183: python: L226 C1: L226 C18: L226 C1: L226 C18
+: 184: jinja2: L226 C19: L226 C26: L226 C19: L226 C26
+: 185: python: L226 C27: L226 C28: L226 C27: L226 C28
+: 186: jinja2: L226 C29: L226 C39: L226 C29: L226 C39
+: 187: python: L226 C40: L226 C43: L226 C40: L226 C43
+: 188: python: L227 C1: L227 C20: L227 C1: L227 C20
+: 189: jinja2: L227 C21: L227 C31: L227 C21: L227 C31
+: 190: python: L227 C32: L227 C63: L227 C32: L227 C63
+: 191: python: L228 C1: L256 C47: L228 C1: L256 C47
+: 192: python: L257 C1: L257 C39: L257 C1: L257 C39
+: 193: jinja2: L257 C40: L257 C65: L257 C40: L257 C65
+: 194: python: L257 C66: L257 C77: L257 C66: L257 C77
+: 195: python: L258 C1: L335 C10: L258 C1: L335 C10
+: 196: jinja2: L336 C1: L336 C26: L336 C1: L336 C26
+: 197: python: L337 C1: L337 C27: L337 C1: L337 C27
+: 198: jinja2: L338 C1: L338 C11: L338 C1: L338 C11
+: 199: python: L339 C1: L342 C27: L339 C1: L342 C27
+: 200: jinja2: L343 C1: L343 C19: L343 C1: L343 C19
+: 201: python: L344 C1: L345 C42: L344 C1: L345 C42
+: 202: jinja2: L346 C1: L346 C11: L346 C1: L346 C11
+: 203: python: L347 C1: L352 C26: L347 C1: L352 C26
+: 204: jinja2: L353 C1: L353 C32: L353 C1: L353 C32
+: 205: python: L354 C1: L354 C31: L354 C1: L354 C31
+: 206: jinja2: L355 C1: L355 C10: L355 C1: L355 C10
+: 207: python: L356 C1: L361 C23: L356 C1: L361 C23
+: 208: jinja2: L362 C1: L362 C47: L362 C1: L362 C47
+: 209: python: L363 C1: L363 C34: L363 C1: L363 C34
+: 210: jinja2: L364 C1: L365 C10: L364 C1: L365 C10
+: 211: python: L366 C1: L368 C5: L366 C1: L368 C5
\ No newline at end of file

From 5b86750c193efd7c995a5bf3615cc9657c8e17a9 Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Wed, 21 Aug 2019 16:44:45 +0530
Subject: [PATCH 05/19] test-requirement.txt: Add regex

Regex module is used in PyJinjaParser to
extract the NlSections. Hence adding this
in the test-requirement.txt
---
 test-requirements.txt | 1 +
 1 file changed, 1 insertion(+)
 mode change 100644 => 100755 test-requirements.txt

diff --git a/test-requirements.txt b/test-requirements.txt
old mode 100644
new mode 100755
index 7376a2c1e..fae19586a
--- a/test-requirements.txt
+++ b/test-requirements.txt
@@ -30,3 +30,4 @@ pip<10
 six>=1.11.0
 wheel~=0.29
 testfixtures~=5.3.1
+regex

From fe54857ecfd4457b4869c45a3f4d8f9608e634ff Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Wed, 21 Aug 2019 16:57:11 +0530
Subject: [PATCH 06/19] requirements.txt: Add regex module

Regex module is used by PyJinjaParser.
---
 requirements.txt | 1 +
 1 file changed, 1 insertion(+)

diff --git a/requirements.txt b/requirements.txt
index 7ec4b1a6a..cc6f1eef8 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -10,3 +10,4 @@ PyPrint~=0.2.6
 requests~=2.12
 setuptools>=21.2.2
 unidiff~=0.5.2
+regex

From 6cd1bc67177f56cad57c6d7e98fcee83bb797608 Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Wed, 21 Aug 2019 17:19:02 +0530
Subject: [PATCH 07/19] DefaultArgParser.py: Add nested language mode

This PR, adds the arguments that will be needed to
run coala in Nested language mode.

The new arguments added are:
1. `--handle-nested`: Used to specify the nl mode
2. '--language1: Tells about the languages present in nl file
---
 coalib/parsing/DefaultArgParser.py    | 11 +++++++++++
 tests/parsing/DefaultArgParserTest.py |  0
 2 files changed, 11 insertions(+)
 mode change 100644 => 100755 coalib/parsing/DefaultArgParser.py
 mode change 100644 => 100755 tests/parsing/DefaultArgParserTest.py

diff --git a/coalib/parsing/DefaultArgParser.py b/coalib/parsing/DefaultArgParser.py
old mode 100644
new mode 100755
index c25af924d..002cd409c
--- a/coalib/parsing/DefaultArgParser.py
+++ b/coalib/parsing/DefaultArgParser.py
@@ -1,4 +1,5 @@
 import argparse
+import sys
 import os
 
 from coalib.misc import Constants
@@ -177,6 +178,12 @@ def default_arg_parser(formatter_class=None):
         '-d', '--bear-dirs', type=PathArg, nargs='+', metavar='DIR',
         help='additional directories which may contain bears')
 
+    # Only required when `handle-nested` is provided
+    inputs_group.add_argument(
+        '--languages', nargs='+', metavar='LANG',
+        required='--handle-nested' in sys.argv,
+        help='nested languages present in the file')
+
     outputs_group = arg_parser.add_argument_group('Outputs')
 
     outputs_group.add_argument(
@@ -293,6 +300,10 @@ def default_arg_parser(formatter_class=None):
              'on unexpected internal exceptions '
              '(implies --verbose)')
 
+    misc_group.add_argument(
+        '--handle-nested', const=True, action='store_const',
+        help='lint files having nested languages')
+
     global argcomplete
     if argcomplete is None:
         try:
diff --git a/tests/parsing/DefaultArgParserTest.py b/tests/parsing/DefaultArgParserTest.py
old mode 100644
new mode 100755

From 1c0035d1350af72c139d0cb95023e20ad405ee07 Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Wed, 21 Aug 2019 18:09:54 +0530
Subject: [PATCH 08/19] TestUtilities.py: Add PEP8TestBear, Jinja2TestBear

Add PEP8TestBear and Jinja2TestBear for running the
tests on NestedLanguage files
---
 tests/TestUtilities.py             |  4 ++++
 tests/test_bears/Jinja2TestBear.py | 14 ++++++++++++++
 tests/test_bears/PEP8TestBear.py   | 14 ++++++++++++++
 3 files changed, 32 insertions(+)
 mode change 100644 => 100755 tests/TestUtilities.py
 create mode 100755 tests/test_bears/Jinja2TestBear.py
 create mode 100755 tests/test_bears/PEP8TestBear.py

diff --git a/tests/TestUtilities.py b/tests/TestUtilities.py
old mode 100644
new mode 100755
index 75fe2e1f4..bbbdc98f3
--- a/tests/TestUtilities.py
+++ b/tests/TestUtilities.py
@@ -13,7 +13,9 @@
     'EchoBear',
     'ErrorTestBear',
     'JavaTestBear',
+    'Jinja2TestBear',
     'LineCountTestBear',
+    'PEP8TestBear',
     'RaiseTestBear',
     'RaiseTestExecuteBear',
     'SpaceConsistencyTestBear',
@@ -89,8 +91,10 @@
     "<class 'AspectsGeneralTestBear.AspectsGeneralTestBear'>",
     "<ErrorTestBear linter class (wrapping 'I_do_not_exist')>",
     "<class 'JavaTestBear.JavaTestBear'>",
+    "<class 'Jinja2TestBear.Jinja2TestBear'>",
     "<class 'LineCountTestBear.LineCountTestBear'>",
     "<EchoBear linter class (wrapping 'echo')>",
+    "<class 'PEP8TestBear.PEP8TestBear'>",
     "<class 'RaiseTestBear.RaiseTestBear'>",
     "<class 'RaiseTestBear.RaiseTestExecuteBear'>",
     "<class 'TestBear.TestBear'>",
diff --git a/tests/test_bears/Jinja2TestBear.py b/tests/test_bears/Jinja2TestBear.py
new file mode 100755
index 000000000..4fbfd4a6d
--- /dev/null
+++ b/tests/test_bears/Jinja2TestBear.py
@@ -0,0 +1,14 @@
+from coalib.bears.LocalBear import LocalBear
+
+
+class Jinja2TestBear(LocalBear):
+    LANGUAGES = {'jinja2'}
+    LICENSE = 'AGPL-3.0'
+    CAN_FIX = {'Formatting'}
+
+    def run(self, filename, file, config: str = ''):
+        """
+        Bear to test that collecting of languages works.
+
+        :param config: An optional dummy config file.
+        """
diff --git a/tests/test_bears/PEP8TestBear.py b/tests/test_bears/PEP8TestBear.py
new file mode 100755
index 000000000..962400991
--- /dev/null
+++ b/tests/test_bears/PEP8TestBear.py
@@ -0,0 +1,14 @@
+from coalib.bears.LocalBear import LocalBear
+
+
+class PEP8TestBear(LocalBear):
+    LANGUAGES = {'python'}
+    LICENSE = 'AGPL-3.0'
+    CAN_FIX = {'Formatting'}
+
+    def run(self, filename, file, config: str = ''):
+        """
+        Bear to test that collecting of languages works.
+
+        :param config: An optional dummy config file.
+        """

From 27fecf92474b1f5334469c29205fe501aeee04ba Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Wed, 21 Aug 2019 18:11:19 +0530
Subject: [PATCH 09/19] NlInfoExtractor: Add NlInfoExractor

NlInfoExtractor is used to extract the information from
the arguments provide when running coala in nested language
mode. It extracts information such:

1. Name of languages
2. Mapping of language with it's temporary files,
3. Mapping of bear with the languages
4. Mapping of orig_files and the temporary languages

NlInfoExtractor also converts the arg_list provided into args
that coala can use.
---
 coalib/nestedlib/NlInfoExtractor.py    | 259 +++++++++++++++++++++++++
 tests/nestedlib/NlInfoExtractorTest.py | 154 +++++++++++++++
 2 files changed, 413 insertions(+)
 create mode 100755 coalib/nestedlib/NlInfoExtractor.py
 create mode 100755 tests/nestedlib/NlInfoExtractorTest.py

diff --git a/coalib/nestedlib/NlInfoExtractor.py b/coalib/nestedlib/NlInfoExtractor.py
new file mode 100755
index 000000000..0599fc15b
--- /dev/null
+++ b/coalib/nestedlib/NlInfoExtractor.py
@@ -0,0 +1,259 @@
+import logging
+from copy import deepcopy
+from coalib.bears.BEAR_KIND import BEAR_KIND
+from coalib.collecting.Collectors import (
+    collect_bears, collect_bears_by_aspects, get_all_bears)
+
+
+SUPPORTED_LANG_COMB = [{'python', 'jinja2'}]
+
+
+def get_temp_file_lang(nl_info_dict, temp_file):
+    """
+    Return the language of the temp created file.
+    """
+    for file, file_info in nl_info_dict['nl_file_info'].items():
+        for lang, temp_file_name in file_info.items():
+            if temp_file == temp_file_name:
+                return lang
+
+
+def get_orig_file(nl_info_dict, temp_file):
+    """
+    Return the original file name for the temp_file
+    """
+    for file, file_info in nl_info_dict['nl_file_info'].items():
+        for lang, temp_file_name in file_info.items():
+            if temp_file == temp_file_name:
+                return file
+
+
+def check_lang_support(lang_list):
+    """
+    Check if the languages supplied by the user is supported by the nested
+    language mode of coala.
+
+    :param lang_list: List containing all the nested languages specified by the
+                      user.
+    """
+    lang_supported = False
+    lang_list = [lang.lower() for lang in lang_list]
+    lang_set = set(lang_list)
+
+    for supported_lang_set in SUPPORTED_LANG_COMB:
+        # The combination of the languages are supported if the difference of
+        # the set is zero.
+        if not supported_lang_set.difference(lang_set):
+            lang_supported = True
+
+    if not lang_supported:
+        logging.error('The language combination are not supported. ' +
+                      'Please check if the languages are provided with' +
+                      'the correct names')
+        raise SystemExit(2)
+
+
+def generate_lang_bear_dict(nl_info_dict):
+    """
+    Map the language with bears specified in the CLI arguments.
+
+    :param nl_info_dict: Dictionary containing the information about the nested
+                         language files sepecified by the user.
+    :return:             Returns a dictionary with `language` as the key and
+                         `bears` as the value.
+    For eg: If the user specified that the nested language files has python
+    and jinja2 as languages and the bears we want to run is `PEP8Bear`,
+    `Jinja2Bear` and `SpaceConsistencyBear`.
+
+    >> nl_info_dict = {}
+    >> nl_info_dict['languages'] = ['python', 'jinja2']
+    >> nl_info_dict['bears'] = ['PEP8Bear','Jinja2Bear', 'SpaceConsistencyBear']
+    >> generate_lang_bear_dict(nl_info_dict)
+    {'python':['PEP8Bear','SpaceConsistencyBear'],
+     'jinja': ['Jinja2Bear', 'SpaceConsistencyBear']
+    }
+
+    """
+    lang_bear_dict = {}
+    bears = nl_info_dict.get('bears', '')
+    bear_dirs = nl_info_dict.get('bear_dirs', None)
+
+    from coalib.settings.Section import Section
+    local_bears, global_bears = collect_bears(
+        bear_dirs if bear_dirs else Section('').bear_dirs(),
+        bears,
+        [BEAR_KIND.LOCAL, BEAR_KIND.GLOBAL],
+        warn_if_unused_glob=False)
+
+    # Initialze the lang_bear_dict
+    for lang in nl_info_dict.get('languages'):
+        lang_bear_dict[lang] = []
+
+    # Create a dictionary for local bears and global bears
+    for bear in local_bears + global_bears:
+        # for bear in bears:
+
+        bear_lang = [lang.lower() for lang in bear.LANGUAGES]
+
+        if 'all' in bear_lang:
+            for lang in nl_info_dict.get('languages'):
+                lang_bear_dict[lang].append(bear.name)
+            continue
+
+        for lang in nl_info_dict.get('languages'):
+            if lang in bear_lang:
+                lang_bear_dict[lang].append(bear.name)
+
+    return lang_bear_dict
+
+
+def nl_info_dict(args=None):
+    """
+    Return a dictionary with the information about nested language file.
+
+    nl_info_dict : The dictionaray containing all the details
+
+    For eg: If the user passes the following arguments to coala
+
+    ```
+    coala --handle-nested --languages=python,jinja2 --files=test.py,test2.py
+    --bears=PEP8Bear,SpaceConsistencyBear,Jinja2Bear --settings use_space=True
+    ```
+
+    If the above args are passed to nl_info dict, the output we get is:
+    ```
+    {
+        'bears': ['PEP8Bear', 'SpaceConsistencyBear', 'GitCommitBear'],
+        'files': ['test.py', 'test2.py'],
+        'lang_bear_dict': {
+                            'jinja2': ['SpaceConsistencyBear'],
+                            'python': ['PEP8Bear', 'SpaceConsistencyBear']
+                          },
+        'languages': ['python', 'jinja2'],
+    }
+    ```
+    The details of keys in nl_info_dict are:
+    :key bears:          Bears specified by the user
+    :key files:          Nested Files to run the analysis on
+    :key languages:      Languages present in the nested file
+    :key lang_bear_dict: Dictionary with `language` as the key and the `bear` as
+                         `values`
+    """
+    nl_info_dict = {}
+    for arg_key, arg_value in sorted(vars(args).items()):
+        if not arg_value:
+            continue
+
+        arg_key = str(arg_key).lower().strip()
+
+        if (arg_key == 'files' or arg_key == 'bears' or arg_key == 'languages'
+                or arg_key == 'bear_dirs'):
+            arg_values = (arg_value[0].strip()).split(',')
+            if arg_key == 'languages':
+                # In order to avoid the upper and lower case mistakes from user
+                # while defining the languages
+                arg_values = [lang.lower() for lang in arg_values]
+                nl_info_dict[arg_key] = arg_values
+            else:
+                nl_info_dict[arg_key] = arg_values
+
+    check_lang_support(nl_info_dict['languages'])
+
+    nl_info_dict['lang_bear_dict'] = generate_lang_bear_dict(nl_info_dict)
+
+    return nl_info_dict
+
+
+def generate_arg_list(args=None):
+    """
+    Generates seperate argument list for each of the nested language.
+
+    The input to the function is the original arg object that the user passed
+    to coala. We make a copy of the original argument object for each of the
+    new argument object we make for each language.
+
+    What we do here is just change the values present in the arg.__dict__ this
+    makes it look like as if the args have been passed  via the command line.
+    Since we cannot regenerate the args as these first scanned by the shell
+    and then passed to the python.
+
+    The following values in the args will be changed:
+
+    :key files:  A new temp file name that will be used to store all the lines
+                 from a particular language
+    :key bears:  The bears that should run for the specific files.
+
+    For eg:
+
+    If the original args passed to coala is,
+    ```
+    coala --handle-nested --languages=python,jinja2 --files=test.py,test2.py
+    --bears=PEP8Bear,SpaceConsistencyBear,Jinja2Bear --settings use_space=True
+    ```
+
+    If the above args are passed to generate_arg_list, the output of nl_info we
+    get is:
+    ```
+    {
+        'bears': ['PEP8Bear', 'SpaceConsistencyBear', 'GitCommitBear'],
+        'files': ['test.py', 'test2.py'],
+        'lang_bear_dict': {
+                            'jinja2': ['SpaceConsistencyBear'],
+                            'python': ['PEP8Bear', 'SpaceConsistencyBear']
+                          },
+        'languages': ['python', 'jinja2'],
+        'nl_file_info': { 'test.py' : {
+                                        'python' : 'test.py_nl_python',
+                                        'jinja2' : 'test.py_nl_jinja2'
+                                      },
+
+                          'test2.py': {
+                                        'python' : 'test2.py_nl_python',
+                                        'jinja2' : 'test2.py_nl_jinja2'
+                                      }
+                        }
+    }
+
+    When the above args are passed to generate_arg_list, it returns the
+    following argument objects, which is equivalent to the following
+
+    ```
+    coala --files=test.py_nl_python --bears=PEP8Bear,SpaceConsistencyBear
+    ```
+
+    ```
+    coala --files=test2.py_nl_python --bears=PEP8Bear,SpaceConsistencyBear
+    ```
+
+    ```
+    coala --files=test.py_nl_jinja2 --bears=Jinja2Bear,SpaceConsistencyBear
+    ```
+
+    ```
+    coala --files=test.py_nl_jinja2 --bears=Jinja2Bear,SpaceConsistencyBear
+    ```
+
+    """
+    nl_info = nl_info_dict(args)
+
+    # Initialize nl_file_info dict
+    nl_info['nl_file_info'] = {}
+    for file in nl_info['files']:
+        nl_info['nl_file_info'][file] = {}
+
+    # Generate the arguments for each language
+    arg_list = []
+    for lang in nl_info['languages']:
+        for file in nl_info['files']:
+            # Create a new instance of args
+            arg_lang = deepcopy(args)
+            temp_nl_file = file + '_nl_' + str(lang)
+
+            nl_info['nl_file_info'][file][lang] = temp_nl_file
+            arg_lang.__dict__['files'] = temp_nl_file
+            arg_lang.__dict__['bears'] = ','.join(
+                                            nl_info['lang_bear_dict'][lang])
+
+            arg_list.append(arg_lang)
+
+    return arg_list, nl_info
diff --git a/tests/nestedlib/NlInfoExtractorTest.py b/tests/nestedlib/NlInfoExtractorTest.py
new file mode 100755
index 000000000..026f717ce
--- /dev/null
+++ b/tests/nestedlib/NlInfoExtractorTest.py
@@ -0,0 +1,154 @@
+import os
+import unittest
+import logging
+from copy import deepcopy
+
+
+from coalib.parsing.DefaultArgParser import default_arg_parser
+from coalib.nestedlib.NlInfoExtractor import (nl_info_dict,
+                                              check_lang_support,
+                                              generate_lang_bear_dict,
+                                              generate_arg_list, get_orig_file,
+                                              get_temp_file_lang)
+
+
+class NlInfoExtractor(unittest.TestCase):
+
+    def setUp(self):
+        self.arg_parser = default_arg_parser()
+        self.test_dir_path = os.path.abspath(__file__ + "/../..")
+        self.test_bear_path = os.path.join(self.test_dir_path, "test_bears")
+        # Both the upper case and lower case is supported in `languages`
+        # argument
+        self.args = self.arg_parser.parse_args([
+                                    '-f', 'test.py.jj2,test2.py.jj2',
+                                    '-b',
+                                'PEP8TestBear,Jinja2TestBear,LineCountTestBear',
+                                '--handle-nested', '--languages',
+                                'PYTHON,Jinja2',
+                                '--bear-dirs='+self.test_bear_path])
+
+    def test_nl_info_dict(self):
+
+        nl_info_dictionay = nl_info_dict(self.args)
+        expected_dictionary = {
+            'bears': ['PEP8TestBear', 'Jinja2TestBear', 'LineCountTestBear'],
+            'bear_dirs': [self.test_bear_path],
+            'files': ['test.py.jj2', 'test2.py.jj2'],
+            'languages': ['python', 'jinja2'],
+            'lang_bear_dict': {
+                             'jinja2': ['Jinja2TestBear', 'LineCountTestBear'],
+                             'python': ['PEP8TestBear', 'LineCountTestBear']
+
+            }
+        }
+
+        self.assertEqual(nl_info_dictionay, expected_dictionary)
+
+    def test_check_lang_support(self):
+        lang_list = ['PYTHON', 'JINAJA21']
+        # If wrong languages are passed - Exit from the execution
+        logger = logging.getLogger()
+        with self.assertLogs(logger, 'ERROR') as cm:
+            with self.assertRaises(SystemExit):
+                check_lang_support(lang_list)
+                self.assertRegex(
+                    cm.output[0],
+                    "The language combination are not supported. "
+                    "Please check if the languages are provided with"
+                    "the correct names")
+
+        uut_lang_list = ['PYTHON', 'JiNjA2']
+        check_lang_support(uut_lang_list)
+
+    def test_generate_lang_bear_dict(self):
+        nl_info_dictionay = nl_info_dict(self.args)
+        uut_lang_bear_dict = generate_lang_bear_dict(nl_info_dictionay)
+        expected_lang_bear_dict = {
+                             'jinja2': ['Jinja2TestBear', 'LineCountTestBear'],
+                             'python': ['PEP8TestBear', 'LineCountTestBear']
+
+                        }
+        self.assertEqual(uut_lang_bear_dict, expected_lang_bear_dict)
+
+    """
+    def test_bear_dirs(self):
+        section = Section('section', None)
+        empty_bear_dirs_len = len(section.bear_dirs())
+        section.append(Setting('bear_dirs', 'test1, test2 (1)'))
+        self.assertEqual(len(section.bear_dirs()), empty_bear_dirs_len + 2)
+        # Verify if bear directories are properly escaped
+        root = get_config_directory(section)
+        path = os.path.join(glob_escape(root), glob_escape('test2 (1)'), '**')
+        self.assertIn(path, section.bear_dirs())
+    """
+
+    def test_generate_arg_list(self):
+
+        self.maxDiff = None
+
+        arg_list = []
+        # First Argument object
+        arg1 = deepcopy(self.args)
+        arg1.__dict__['files'] = 'test.py.jj2_nl_python'
+        arg1.__dict__['bears'] = 'PEP8TestBear,LineCountTestBear'
+        arg_list.append(arg1)
+
+        # Second Argument object
+        arg2 = deepcopy(self.args)
+        arg2.__dict__['files'] = 'test2.py.jj2_nl_python'
+        arg2.__dict__['bears'] = 'PEP8TestBear,LineCountTestBear'
+        arg_list.append(arg2)
+
+        # Third Argument Object
+        arg3 = deepcopy(self.args)
+        arg3.__dict__['files'] = 'test.py.jj2_nl_jinja2'
+        arg3.__dict__['bears'] = 'Jinja2TestBear,LineCountTestBear'
+        arg_list.append(arg3)
+
+        # Fourth Argument Object
+        arg4 = deepcopy(self.args)
+        arg4.__dict__['files'] = 'test2.py.jj2_nl_jinja2'
+        arg4.__dict__['bears'] = 'Jinja2TestBear,LineCountTestBear'
+        arg_list.append(arg4)
+
+        # Expected nl_info_dict
+        expected_nl_info = {
+            'bears': ['PEP8TestBear', 'Jinja2TestBear', 'LineCountTestBear'],
+            'bear_dirs': [self.test_bear_path],
+            'files': ['test.py.jj2', 'test2.py.jj2'],
+            'lang_bear_dict': {
+                                'jinja2': ['Jinja2TestBear',
+                                           'LineCountTestBear'],
+                                'python': ['PEP8TestBear', 'LineCountTestBear']
+                            },
+            'languages': ['python', 'jinja2'],
+            'nl_file_info': {'test.py.jj2': {
+                                            'python': 'test.py.jj2_nl_python',
+                                            'jinja2': 'test.py.jj2_nl_jinja2'
+                                        },
+
+                             'test2.py.jj2': {
+                                            'python': 'test2.py.jj2_nl_python',
+                                            'jinja2': 'test2.py.jj2_nl_jinja2'
+                                        }
+                             }
+        }
+
+        uut_arg_list, uut_nl_info = generate_arg_list(self.args)
+
+        self.assertEqual(uut_arg_list, arg_list)
+        self.assertEqual(uut_nl_info, expected_nl_info)
+
+    def test_get_orig_file(self):
+        uut_arg_list, uut_nl_info = generate_arg_list(self.args)
+        uut_temp_file_name = 'test2.py.jj2_nl_python'
+        uut_file = get_orig_file(uut_nl_info, uut_temp_file_name)
+        self.assertEqual(uut_file, 'test2.py.jj2')
+
+    def test_get_temp_file_lang(self):
+        uut_arg_list, uut_nl_info = generate_arg_list(self.args)
+        uut_temp_file_name = 'test.py.jj2_nl_jinja2'
+        uut_temp_file_lang = get_temp_file_lang(
+            uut_nl_info, uut_temp_file_name)
+        self.assertEqual(uut_temp_file_lang, 'jinja2')

From 71c0d041a50e704907e34e212fac5f5e0ae4e91d Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Wed, 21 Aug 2019 20:23:17 +0530
Subject: [PATCH 10/19] NlFileHandler: Add NlFileHandler

This PR adds the NlFileHandler.

NlFileHandler is reponsible to create the file dicts
of the segreagted pure language. It is also used to
preprocess the nl_file_dicts to add the position markers
to the nl_file_dicts to mark the position of sections
in the file.
---
 coalib/nestedlib/NlFileHandler.py    | 376 ++++++++++++++
 tests/nestedlib/NlFileHandlerTest.py | 743 +++++++++++++++++++++++++++
 2 files changed, 1119 insertions(+)
 create mode 100755 coalib/nestedlib/NlFileHandler.py
 create mode 100755 tests/nestedlib/NlFileHandlerTest.py

diff --git a/coalib/nestedlib/NlFileHandler.py b/coalib/nestedlib/NlFileHandler.py
new file mode 100755
index 000000000..981d7c02a
--- /dev/null
+++ b/coalib/nestedlib/NlFileHandler.py
@@ -0,0 +1,376 @@
+from coalib.io.File import File
+from copy import deepcopy
+import logging
+
+# This is used to combine the nl_sections of a mixed language line produced by
+# a parser  into a single nl_section.
+PARSER_MIXED_LINE_COMB = [{'PyJinjaParser': 'jinja2'}]
+
+
+def get_nl_sections(all_nl_sections, lang):
+    """
+    Get the nl_section of a particular language from all the nl_sections of the
+    file. And sort the nl_section according to their index.
+
+    When the parser parses the file, it returns a list of nl_section containing
+    all the nested language. In order to make a file_dict, only the sections
+    belonging to one language is needed.
+
+    :param all_nl_sections: The list of nl_sections the parser ouputs
+    :param lang:            The language whose nl_section is needed.
+    """
+    # Get nl_section of `lang` language
+    nl_sections = []
+    for nl_section in all_nl_sections:
+        if nl_section.language == lang:
+            nl_sections.append(nl_section)
+
+    # Sort the nl_sections according to their indices
+    nl_sections = sorted(nl_sections, key=lambda nl_section: nl_section.index)
+    return nl_sections
+
+
+def get_line_list(nl_sections, orig_file_path):
+    """
+    Create a list of lines that would be present in the temporary file.
+
+    From the nl_sections, get the information of start and end and use this to
+    get the content at those positions.
+
+    :param nl_sections:     The nl_sections belonging to one language
+    :param orig_file_path:  The absolute path of the original nested file.
+    """
+    file = File(orig_file_path)
+
+    # Initialiaze a line_list with whitespace. The lenght of this list will
+    # be equal to the number of lines in the actual files.
+    # The index of the list points to the line number of the original file.
+    # The means line_list[3] contains the line at line number 4 of the original
+    # file.
+    line_list = []
+    line_list = [' ' for index in range(0, file.__len__())]
+
+    for nl_section in nl_sections:
+
+        start_line = nl_section.start.line
+        start_column = nl_section.start.column
+        end_line = nl_section.end.line
+        end_column = nl_section.end.column
+
+        for line_nr in range(start_line, end_line+1):
+
+            # Make the length of line equal to the length of original line
+            if(line_list[line_nr-1].isspace()):
+                line_list[line_nr-1] = ' '*len(file[line_nr-1])
+
+            orig_line = file[line_nr-1]
+            end_orig_line = len(orig_line)-1
+            line = line_list[line_nr-1]
+
+            # If the section contains only one line.
+            # This case generally happens for mixed lang line
+            if (line_nr == start_line and line_nr == end_line):
+
+                # If column is not mentioned, then it means that the entire line
+                # is present in the section.
+                if (not end_column) or (not start_column):
+                    line_list[line_nr-1] = orig_line
+
+                else:
+                    # section_content stores the part of the line that belongs
+                    # to the section.
+                    section_content = file[line_nr -
+                                           1][start_column-1:end_column]
+
+                    if(start_column-1 > 0) and (end_column < end_orig_line):
+                        line_list[line_nr-1] = (line[0:start_column-1] +
+                                                section_content +
+                                                line[end_column:end_orig_line])
+
+                    elif(start_column-1 == 0) and (end_column < end_orig_line):
+                        line_list[line_nr-1] = (section_content +
+                                                line[end_column:end_orig_line])
+
+                    elif(start_column-1 > 0) and (end_column == end_orig_line):
+                        line_list[line_nr-1] = (line[0:start_column-1] +
+                                                section_content)
+                    else:
+                        line_list[line_nr-1] = section_content
+
+            elif (line_nr == start_line):
+                line_list[line_nr-1] = orig_line
+
+            elif (line_nr == end_line):
+                if(end_column == len(orig_line)-1):
+                    line_list[line_nr-1] = orig_line
+                else:
+                    line_list[line_nr-1] = (orig_line[0:end_column-1] +
+                                            line[end_column-1:end_orig_line])
+
+            else:
+                line_list[line_nr-1] = orig_line
+    return line_list
+
+
+def beautify_line_list(line_list):
+    """
+    Beautify the line list.
+
+    It add a newline character at the end of items if newline character is not
+    not present and also adds a newline character if the item is only
+    space. Because those line might have been either a pure line or an empty
+    line.
+
+    :param line_list: The list containing all the lines of temporary file.
+    :return:          The beautified tuple containing all the lines.
+
+    >>> line_list = ['', '\\n','asdas adasd', 'asdasdawq12\\n']
+    >>> beautify_line_list(line_list)
+    ('\\n', '\\n', 'asdas adasd\\n', 'asdasdawq12\\n')
+
+    """
+    for i, line in enumerate(line_list):
+        if not line.strip():
+            line_list[i] = '\n'
+        elif line[-1] == '\n':
+            continue
+        else:
+            line_list[i] += '\n'
+
+    return(tuple(line_list))
+
+
+def is_mixed_lang_section(all_nl_sections, nl_section_to_check):
+    """
+    Check if the nl_section is a part of mixed nl_section.
+
+    Note that, every mixed_nl_line was divided into a seperate nl_section.
+    They were/are not suppsed to be mixed with pure_language lines. So we
+    can find the mixed_nl_section, if we find that there are more than one
+    nl_section that same start_line and end_line.
+
+    We return the number of nl_sections present on the line, so that we can
+    jump by that many sections, instead of checking them again and again.
+    """
+    start_line = nl_section_to_check.start.line
+
+    all_nl_sections_line = [nl_section for nl_section in all_nl_sections
+                            if nl_section.start.line == start_line]
+
+    if (len(all_nl_sections_line) > 1):
+        return True, len(all_nl_sections_line)
+
+    return False, 0
+
+
+def get_preprocessed_nl_sections(all_nl_sections, parser):
+    """
+    Preprocess the nl_sections.
+
+    The parser converts the original nested language file into different
+    nl_sections. During those conversion, we encounter two types of files,
+    one pure lines and mixed language lines. The pure languages lines were
+    grouped into one section and they were never appeneded with the the mixed
+    language lines. The mixed languge lines were divided into various different
+    nl_sections.
+
+    This function converts the sections generated by the parser for the mixed
+    language lines into a single section. We are doing this with an
+    understanding that when two languages are nested, there is usually some form
+    of depenedcy in each othere. In such cases, we are sure that atleast one of
+    the bear writer would have written the bear such that it ignores the other
+    language.
+
+    For example: For a file that has both Jinja and Python nested. We can see
+    that Jinja2Bear, lints only the jinja lines ignoring the python lines.
+    We can make use of this functionality while linting. That means, we could
+    pass the mixed language line to the Jinja2Bear which could lint the
+    mixed language.
+
+    The problem with the above approach is that in mixed_language lines only
+    the jinja2 part will be linted and not python lines.
+
+    NOTE: This is only a temporary solution. We could use this until we find
+    how to lint the nl_section which are  of mixed language using the position
+    markers.
+    """
+    # Get the language you want to mark the mixed_language lines with.
+    # For eg: In a combination of Python and Jinja, we mark the mixed lang
+    # nl_sections with jinja2 since Jinja2Bear can lint through them
+    parser_name = parser.__class__.__name__
+    mixed_lang = ""
+    for parser_mixed_lang_dict in PARSER_MIXED_LINE_COMB:
+        for parser, lang in parser_mixed_lang_dict.items():
+            if parser_name.lower() == parser.lower():
+                mixed_lang = lang
+                break
+
+    if not mixed_lang:
+        logging.error("No PARSER_MIXED_LINE_COMB exist")
+        raise SystemExit(2)
+
+    preprocessed_nl_section_index = 1
+    preprocess_nl_sections = []
+    index = 0
+    # Get new nl_section which aggregates the mixed_lang section into one.
+    while(index < len(all_nl_sections)):
+
+        nl_section = all_nl_sections[index]
+        mixed_lang_section, num_mixed_nl_sections = is_mixed_lang_section(
+                                                  all_nl_sections[index:],
+                                                  nl_section_to_check=nl_section)
+        if mixed_lang_section:
+            mixed_nl_section = deepcopy(nl_section)
+            mixed_nl_section.start.column = None
+            mixed_nl_section.end.column = None
+            mixed_nl_section.linted_start.column = None
+            mixed_nl_section.linted_end.column = None
+            mixed_nl_section.language = mixed_lang
+            mixed_nl_section.index = preprocessed_nl_section_index
+
+            preprocess_nl_sections.append(mixed_nl_section)
+
+            # Since the current nl_section is a mixed section, there will surely
+            # be few other another mixed_nl_sections below it. It's useless
+            # num_mixed_nl_section also includes the current section
+            index = index + (num_mixed_nl_sections)
+            preprocessed_nl_section_index += 1
+
+        else:
+            pure_nl_section = deepcopy(nl_section)
+            pure_nl_section.index = preprocessed_nl_section_index
+            preprocess_nl_sections.append(pure_nl_section)
+            preprocessed_nl_section_index += 1
+            index += 1
+
+    return preprocess_nl_sections
+
+
+def preprocess_nl_line_list(nl_sections, lines_list, lang):
+    """
+    Add position markers to the line list to indicate the `start` and `end` of
+    a Nested language section.
+    This helps while retrieving the section from the linted file.
+
+    For eg: Let's assume the following snippet is from a segregated Pyhton temp
+    file from a Python-Jinja nested original file.
+    file
+
+    The following example:
+    ```
+    def (hello):
+        print("Thanos ROCKS!!")
+
+
+    print("Next nl_section starts")
+    ```
+
+    Assume the empty lines to be the lines where jinja2 content was present.
+
+    After preprocessing the above lines looks like:
+    ```
+    # Start nl section 1
+    def (hello):
+        print("Thanos ROCKS!!")
+    # End nl section 1
+
+
+    # Start nl section 2
+    print("Next nl_section starts")
+    # End nl section 2
+    ```
+    We will also include the section number/index into the marker string.
+    This helps while reassembling.
+    Note that the lines where the nl section position markers are present would
+    be ignored by coala.(Refer the ignore_ranges in process/Processing.py).
+    This would remove the worry of they being linted and affecting the actual
+    code.
+    """
+
+    # Add the prefix string according to the language combination.
+    # For now this string works for the combination of Python and Jinja
+    # When more language support is added, You can use `if` statements to
+    # use the proper prefix
+    start_marker_prefix = "# Start Nl Section: "
+    end_marker_prefix = "# End Nl Section: "
+
+    # Store the count of number of lines have been added.
+    added_lines = 0
+
+    for nl_section in nl_sections:
+        index = nl_section.index
+
+        # Insert the start position marker for the nl section
+        start_pos = nl_section.start.line - 1
+        start_pos_marker = start_pos + added_lines
+        start_marker = start_marker_prefix + str(index)
+        lines_list.insert(start_pos_marker, start_marker)
+        added_lines += 1
+        # linted_start maintains the position of the nl_section before it goes
+        # to the bears
+        nl_section.linted_start.line += added_lines
+
+        # Insert the end position marker for the nl section
+        end_pos = nl_section.end.line - 1
+        end_pos_marker = (end_pos + added_lines) + 1
+        end_marker = end_marker_prefix + str(index)
+        lines_list.insert(end_pos_marker, end_marker)
+        nl_section.linted_end.line += added_lines
+        added_lines += 1
+
+    return lines_list
+
+
+def get_nl_file_dict(orig_file_path, temp_file_name, lang, parser):
+    """
+    Return a dictionary with `temp_file_name` as the key and the value as the
+    tuple containing the lines the lines belonging to the param `lang`.
+
+    :param orig_file_path: Path of the original nested file
+    :param temp_file_name: Name of the temporary file that acts as the file
+                           holder which consists of only the lines of the
+                           `lang` language from the originianl nested file.
+                           The temporary files  are said to be the pure
+                           langauge files i.e the files that contains only one
+                           programming language.
+    :param lang:           Specifies the language of the line we want to extract
+                           from the original file.
+    :param parser:         The parser object to make nl_sections.
+
+    Suppose we have the following file contents. And the name of file is
+    `test.py`. Thie file contains both `python` and `jinja2` lines.
+
+    >>> file_contents = ("for x in y:\\n",
+    ...                  "{% if x is True %}\\n",
+    ...                  "\\t{% set var3 = value3 %}\\n",
+    ...                  "{% elif %}\\n",
+    ...                  "\\t\\t{{ var }} = print('Bye Bye')\\n")
+
+
+    The file_dict that contains only `jinja2` lines of the original files are:
+    {'test.py_nl_jinja2': ('\\n',
+                          '{% if x is True %}\\n',
+                           '    {% set var3 = value3 %}\\n',
+                           '{% elif %}\\n',
+                           '        {{ var }}                   \\n')}
+
+    The file_dict that contains only `python` lines of the original file are:
+    {'test.py_nl_python': ('"for x in y:\\n',
+                           '\\n',
+                           '\\n',
+                           '\\n',
+                           "                  = print('Bye Bye')\\n")}
+
+    """
+    # ENHANCEMENT: Maybe instead of making parser parse through the file for
+    # every nested language. We can store it somehow?
+    all_nl_sections = parser.parse(orig_file_path)
+    preprocessed_nl_sections = get_preprocessed_nl_sections(all_nl_sections,
+                                                            parser)
+    nl_sections = get_nl_sections(preprocessed_nl_sections, lang)
+    line_list = get_line_list(nl_sections, orig_file_path)
+    preprocessed_nl_line_list = preprocess_nl_line_list(
+        nl_sections, line_list, lang)
+    line_tuple = beautify_line_list(preprocessed_nl_line_list)
+    file_dict = {temp_file_name: line_tuple}
+    return file_dict
diff --git a/tests/nestedlib/NlFileHandlerTest.py b/tests/nestedlib/NlFileHandlerTest.py
new file mode 100755
index 000000000..c4ca26092
--- /dev/null
+++ b/tests/nestedlib/NlFileHandlerTest.py
@@ -0,0 +1,743 @@
+import os
+import unittest
+from os.path import abspath
+
+from coalib.nestedlib.NlFileHandler import (get_nl_file_dict,
+                                            get_nl_sections,
+                                            get_line_list,
+                                            beautify_line_list,
+                                            get_nl_file_dict,
+                                            get_preprocessed_nl_sections)
+from coalib.nestedlib.parsers.PyJinjaParser import PyJinjaParser
+from coalib.nestedlib.parsers.Parser import (Parser,
+                                             create_nl_section,
+                                             get_file)
+
+
+TEST_FILE_DIR = os.path.join(os.path.split(__file__)[0],
+                             'parsers/file_test_files')
+
+
+class DummyParser(Parser):
+    """
+    Dummy Parser
+    """
+
+    def parse(self, filename):
+        return None
+
+
+class NlFileHandler(unittest.TestCase):
+
+    def setUp(self):
+        self.file_test_dir = TEST_FILE_DIR
+        self.test_filename1 = 'test-jinja-py.py.jj2.txt'
+        self.test_file1_path = os.path.join(self.file_test_dir,
+                                            self.test_filename1)
+        self.abs_test_file1_path = abspath(self.test_file1_path)
+
+        self.parser = PyJinjaParser()
+        self.all_nl_sections = self.parser.parse(self.abs_test_file1_path)
+
+    def test_get_nl_sections(self):
+        uut_lang = 'jinja2'
+        uut_all_nl_sections = self.all_nl_sections
+        uut_nl_sections = get_nl_sections(uut_all_nl_sections, uut_lang)
+        uut_section_list = []
+
+        expected_nl_sections = [
+            self.abs_test_file1_path + ': 2: jinja2: L2 C1: L5 C10:' +
+            ' L2 C1: L5 C10',
+            self.abs_test_file1_path + ': 3: jinja2: L6 C1: L6 C13:' +
+            ' L6 C1: L6 C13'
+        ]
+
+        for nl_section in uut_nl_sections:
+            uut_section_list.append(str(nl_section))
+
+        self.assertEqual(uut_section_list, expected_nl_sections)
+
+    def test_get_line_list(self):
+        uut_lang = 'jinja2'
+        uut_all_nl_sections = self.all_nl_sections
+        uut_nl_sections = get_nl_sections(uut_all_nl_sections, uut_lang)
+        uut_line_list = get_line_list(
+            uut_nl_sections, self.abs_test_file1_path)
+
+        expected_line_list = [' ',
+                              '{% if x is True %}\n',
+                              '    {% set var3 = value3 %}\n',
+                              '    \n',
+                              '{% elif %}\n',
+                              '    {{ var }}                   '
+                              ]
+        self.assertEqual(uut_line_list, expected_line_list)
+
+        test_filename2 = 'test-jinja2-py.jj2.txt'
+
+        test_file2_path = os.path.join(self.file_test_dir,
+                                       test_filename2)
+        abs_test_file2_path = abspath(test_file2_path)
+        uut_lang = 'jinja2'
+        uut_all_nl_sections = self.parser.parse(abs_test_file2_path)
+        uut_nl_sections = get_nl_sections(uut_all_nl_sections, uut_lang)
+        uut_line_list = get_line_list(
+            uut_nl_sections, abs_test_file2_path)
+        expected_line_list = [
+                        ' ',
+                        '{% if x is True %}\n',
+                        '    {% set var3 = value3 %}\n',
+                        '    \n',
+                        '{% elif %}\n',
+                        '    {{ var }}                    {{ y }}    {{ x }}'
+                        ]
+        self.assertEqual(uut_line_list, expected_line_list)
+
+    def test_beautify_line_list(self):
+
+        uut_line_list = ['',
+                         ' ',
+                         '\n',
+                         '  \n',
+                         '\n  ',
+                         '    {% set var3 = value3 %}\n',
+                         '{% elif %}',
+                         '    {{ var }}                   '
+                         ]
+
+        expected_line_tuple = ('\n',
+                               '\n',
+                               '\n',
+                               '\n',
+                               '\n',
+                               '    {% set var3 = value3 %}\n',
+                               '{% elif %}\n',
+                               '    {{ var }}                   \n'
+                               )
+
+        beautified_line_tuple = beautify_line_list(uut_line_list)
+
+        self.assertEqual(beautified_line_tuple, expected_line_tuple)
+
+    def test_get_nl_file_dict(self):
+        uut_temp_file_name = self.test_filename1 + '_nl_jinja2'
+        uut_lang = 'jinja2'
+        uut_file_dict = get_nl_file_dict(self.abs_test_file1_path,
+                                         uut_temp_file_name, uut_lang,
+                                         self.parser)
+
+        expected_file_dict = {
+            'test-jinja-py.py.jj2.txt_nl_jinja2': (
+                '\n',
+                '# Start Nl Section: 2\n',
+                '{% if x is True %}\n',
+                '    {% set var3 = value3 %}\n',
+                '\n',
+                '{% elif %}\n',
+                '# End Nl Section: 2\n',
+                '# Start Nl Section: 3\n',
+                '    {{ var }} = sum_square(x1*2)\n',
+                '# End Nl Section: 3\n'
+            )
+        }
+        self.maxDiff = None
+        self.assertEqual(uut_file_dict, expected_file_dict)
+
+    def test_get_preprocessed_nl_sections(self):
+        uut_all_nl_sections = self.all_nl_sections
+        uut_parser = DummyParser()
+        with self.assertRaises(SystemExit) as cm:
+            preprocessed_nl_sections = get_preprocessed_nl_sections(
+                uut_all_nl_sections, uut_parser)
+
+    def test_coala_setup_template(self):
+        """
+        Test the jinja temporary file generated for coala setup template file.
+        """
+        uut_test_filename = 'test-setup-py.py.jj2.txt'
+        uut_test_file_path = os.path.join(
+            self.file_test_dir, uut_test_filename)
+        uut_abs_test_file_path = abspath(uut_test_file_path)
+        uut_temp_file_name = 'test-setup-py.py.jj2.txt_nl_jinja2'
+
+        temp_file_dict = get_nl_file_dict(uut_abs_test_file_path,
+                                          uut_temp_file_name,
+                                          'jinja2',
+                                          self.parser)
+
+        """
+        # Get the file_dict as a string.
+        # It's easier for comparision
+        temp_file_output_name = 'coala_setup_jinja2_temp_file.py.jj2.txt'
+        temp_file_output_dir = os.path.join(os.path.split(__file__)[0],
+                            'test_files_output')
+        temp_file_output_path = os.path.join(self.temp_file_output_dir,
+                                                temp_file_output_name)
+        abs_temp_file_output_path = abspath(temp_file_output_path)
+        temp_file_dict_output_file = File(abs_temp_file_output_path)
+
+        expected_output_string =  temp_file_dict_output_file.string
+        """
+
+        expected_tuple = (
+            '# Start Nl Section: 1\n',
+            '{% if not scm_host %}\n',
+            "{% set scm_host = 'github.com' %}\n",
+            '{% endif %}\n',
+            '{% block shebang %}\n',
+            '# End Nl Section: 1\n',
+            '\n',
+            '# Start Nl Section: 3\n',
+            '{% endblock %}\n',
+            "{% set min_python_version = " +
+            "min_python_version|default('2.6') %}\n",
+            "{% set min_python_version = " +
+            "min_python_version.split('.', 2) %}\n",
+            '\n',
+            '{% block header %}\n',
+            '# End Nl Section: 3\n',
+            '\n',
+            '# Start Nl Section: 5\n',
+            '{% endblock %}\n',
+            '# End Nl Section: 5\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 7\n',
+            '{% if external_module_library %}\n',
+            '# End Nl Section: 7\n',
+            '\n',
+            '# Start Nl Section: 9\n',
+            '{% else %}\n',
+            '\n',
+            '# End Nl Section: 9\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 11\n',
+            '{%endif%}\n',
+            '{%block compat_block%}\n',
+            '# End Nl Section: 11\n',
+            '\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 13\n',
+            '{%endblock%}\n',
+            '\n',
+            '# End Nl Section: 13\n',
+            '\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 15\n',
+            '{% if PY33 %}\n',
+            '# End Nl Section: 15\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 17\n',
+            '{% endif %}\n',
+            '\n',
+            '# End Nl Section: 17\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 19\n',
+            'NAME = "{{name}}"\n',
+            '# End Nl Section: 19\n',
+            '# Start Nl Section: 20\n',
+            'AUTHOR = "{{author}}"\n',
+            '# End Nl Section: 20\n',
+            '# Start Nl Section: 21\n',
+            'VERSION = "{{current_version}}"\n',
+            '# End Nl Section: 21\n',
+            '# Start Nl Section: 22\n',
+            'EMAIL = "{{contact}}"\n',
+            '# End Nl Section: 22\n',
+            '# Start Nl Section: 23\n',
+            'LICENSE = "{{license}}"\n',
+            '# End Nl Section: 23\n',
+            '# Start Nl Section: 24\n',
+            '{% if MAINTAINER %}\n',
+            '# End Nl Section: 24\n',
+            '# Start Nl Section: 25\n',
+            'MAINTAINER = "{{maintainer}}"\n',
+            '# End Nl Section: 25\n',
+            '# Start Nl Section: 26\n',
+            'MAINTAINER_CONTACT = "{{maintainer_contact}}"\n',
+            '# End Nl Section: 26\n',
+            '# Start Nl Section: 27\n',
+            '{% endif %}\n',
+            '{% if command_line_interface or entry_points %}\n',
+            '# End Nl Section: 27\n',
+            '\n',
+            '# Start Nl Section: 29\n',
+            "{% if not entry_points or 'console_scripts' " +
+            "not in entry_points %}\n",
+            '# End Nl Section: 29\n',
+            '\n',
+            '# Start Nl Section: 31\n',
+            '        "{{command_line_interface}} = {{ entry_point }}"\n',
+            '# End Nl Section: 31\n',
+            '\n',
+            '# Start Nl Section: 33\n',
+            '{% endif %}\n',
+            '{% if entry_points %}\n',
+            '  {% for group_name, items in entry_points.items() %}\n',
+            '# End Nl Section: 33\n',
+            '# Start Nl Section: 34\n',
+            '    "{{group_name}}": [\n',
+            '# End Nl Section: 34\n',
+            '# Start Nl Section: 35\n',
+            '      {% if group_name == "console_scripts" ' +
+            'and command_line_interface %}\n',
+            '# End Nl Section: 35\n',
+            '# Start Nl Section: 36\n',
+            '        "{{command_line_interface}} = {{ entry_point }}",\n',
+            '# End Nl Section: 36\n',
+            '# Start Nl Section: 37\n',
+            '      {% endif %}\n',
+            '      {% for item in items %}\n',
+            '# End Nl Section: 37\n',
+            '# Start Nl Section: 38\n',
+            '        "{{item}}",\n',
+            '# End Nl Section: 38\n',
+            '# Start Nl Section: 39\n',
+            '      {% endfor %}\n',
+            '# End Nl Section: 39\n',
+            '\n',
+            '# Start Nl Section: 41\n',
+            '  {% endfor %}\n',
+            '{% endif %}\n',
+            '# End Nl Section: 41\n',
+            '\n',
+            '# Start Nl Section: 43\n',
+            '{% endif %}\n',
+            '# End Nl Section: 43\n',
+            '\n',
+            '# Start Nl Section: 45\n',
+            '{% for line in description | split_length(70) %}\n',
+            '# End Nl Section: 45\n',
+            '# Start Nl Section: 46\n',
+            '    "{{ line }}"{{ " +" if not loop.last}}\n',
+            '# End Nl Section: 46\n',
+            '# Start Nl Section: 47\n',
+            '{% endfor %}\n',
+            '# End Nl Section: 47\n',
+            '\n',
+            '# Start Nl Section: 49\n',
+            'URL = "https://{{scm_host}}/{{organisation}}/{{name}}"\n',
+            '# End Nl Section: 49\n',
+            '# Start Nl Section: 50\n',
+            'DOWNLOAD_URL = "%s/archive/{{release}}.tar.gz" % URL\n',
+            '# End Nl Section: 50\n',
+            '# Start Nl Section: 51\n',
+            'FILES = ["README.rst",' +
+            '{%block morefiles %}{%endblock%} "CHANGELOG.rst"]\n',
+            '# End Nl Section: 51\n',
+            '# Start Nl Section: 52\n',
+            '{% if self.additional_keywords %}\n',
+            '{% set additional_keywords = ' +
+            'self.additional_keywords() %}\n',
+            '{% if additional_keywords and not '
+            'additional_keywords.rstrip().endswith(",") %}\n',
+            '{% set additional_keywords = '
+            'additional_keywords.rstrip() + ",\\n" %}\n',
+            '{% endif %}\n',
+            '{% endif %}\n',
+            '# End Nl Section: 52\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 54\n',
+            '{% for keyword in keywords %}\n',
+            '# End Nl Section: 54\n',
+            '# Start Nl Section: 55\n',
+            '    "{{keyword}}",\n',
+            '# End Nl Section: 55\n',
+            '# Start Nl Section: 56\n',
+            '{% endfor %}\n',
+            '    {%block additional_keywords -%}\n',
+            '    {%endblock%}\n',
+            '# End Nl Section: 56\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 58\n',
+            '    {% if min_python_version <= ["2", "6"] %}\n',
+            '# End Nl Section: 58\n',
+            '\n',
+            '# Start Nl Section: 60\n',
+            '    {%- endif %}\n',
+            '\n',
+            '    {% if min_python_version <= ["2", "7"] %}\n',
+            '# End Nl Section: 60\n',
+            '\n',
+            '# Start Nl Section: 62\n',
+            '    {%- endif %}\n',
+            '\n',
+            '    {%- if min_python_version[0] == "3" %}\n',
+            '# End Nl Section: 62\n',
+            '\n',
+            '# Start Nl Section: 64\n',
+            '    {%- endif %}\n',
+            '\n',
+            '    {% if min_python_version <= ["3","3"] %}\n',
+            '# End Nl Section: 64\n',
+            '\n',
+            '# Start Nl Section: 66\n',
+            '    {%- endif %}\n',
+            '\n',
+            '    {% if min_python_version <= ["3","4"] %}\n',
+            '# End Nl Section: 66\n',
+            '\n',
+            '# Start Nl Section: 68\n',
+            '    {%- endif %}\n',
+            '\n',
+            '    {% if min_python_version <= ["3","5"] %}\n',
+            '# End Nl Section: 68\n',
+            '\n',
+            '# Start Nl Section: 70\n',
+            '    {%- endif %}\n',
+            '\n',
+            '    {% if min_python_version <= ["3","6"] %}\n',
+            '# End Nl Section: 70\n',
+            '\n',
+            '# Start Nl Section: 72\n',
+            '    {% endif %}\n',
+            '\n',
+            '    {% if min_python_version <= ["3","7"] %}\n',
+            '# End Nl Section: 72\n',
+            '\n',
+            '# Start Nl Section: 74\n',
+            '    {% endif %}\n',
+            '\n',
+            '    {% if min_python_version <= ["3","8"] %}\n',
+            '# End Nl Section: 74\n',
+            '\n',
+            '# Start Nl Section: 76\n',
+            '    {% endif %}\n',
+            '\n',
+            '    {%block additional_classifiers%}\n',
+            '    {%endblock %}\n',
+            '# End Nl Section: 76\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 78\n',
+            '{%macro handle_complex_dependency(complex_one) -%}\n',
+            '{%set dependency, condition = complex_one.split(";")%}\n',
+            '{% if condition == \'python_version<"3"\'%}\n',
+            '# End Nl Section: 78\n',
+            '\n',
+            '# Start Nl Section: 80\n',
+            '{% endif %}\n',
+            '{% if condition == \'python_version>="3"\'%}\n',
+            '# End Nl Section: 80\n',
+            '\n',
+            '# Start Nl Section: 82\n',
+            '{% endif %}\n',
+            '{% if condition == \'python_version<"2.7"\'%}\n',
+            '# End Nl Section: 82\n',
+            '\n',
+            '# Start Nl Section: 84\n',
+            '{% endif %}\n',
+            '{% if condition == \'platform_python_implementation=="PyPy"\'%}\n',
+            '# End Nl Section: 84\n',
+            '\n',
+            '# Start Nl Section: 86\n',
+            '{%endif%}\n',
+            '# End Nl Section: 86\n',
+            '# Start Nl Section: 87\n',
+            "    INSTALL_REQUIRES.append('{{dependency}}')\n",
+            '# End Nl Section: 87\n',
+            '# Start Nl Section: 88\n',
+            '{%- endmacro %}\n',
+            '# End Nl Section: 88\n',
+            '\n',
+            '# Start Nl Section: 90\n',
+            '{% for dependency in dependencies: %}\n',
+            "  {% if ';' not in dependency and not " +
+            "dependency.startswith('#'): %}\n",
+            "    {% if '#egg=' in dependency: %}\n",
+            "      {% set dependency = dependency.split('#egg=') %}\n",
+            '      {% set repo_link, egg_name = dependency[0],' +
+            ' dependency[1] %}\n',
+            '      {% set repo_link = repo_link.strip() %}\n',
+            "      {% if '#' in egg_name: %}\n",
+            "        {% set egg_name = egg_name.split('#')[0].strip() %}\n",
+            '      {% endif %}\n',
+            '# End Nl Section: 90\n',
+            '# Start Nl Section: 91\n',
+            '    "{{[repo_link, egg_name] | join(\'#egg=\')}}",\n',
+            '# End Nl Section: 91\n',
+            '# Start Nl Section: 92\n',
+            "    {% elif '#' in dependency: %}\n",
+            "      {% set dependency = dependency.split('#')[0].strip() %}\n",
+            '# End Nl Section: 92\n',
+            '# Start Nl Section: 93\n',
+            '    "{{dependency}}",\n',
+            '# End Nl Section: 93\n',
+            '# Start Nl Section: 94\n',
+            '    {% else %}\n',
+            '# End Nl Section: 94\n',
+            '# Start Nl Section: 95\n',
+            '    "{{dependency}}",\n',
+            '# End Nl Section: 95\n',
+            '# Start Nl Section: 96\n',
+            '    {% endif %}\n',
+            '  {%   endif %}\n',
+            '{% endfor %}\n',
+            '# End Nl Section: 96\n',
+            '\n',
+            '# Start Nl Section: 98\n',
+            '{% block additional_setup_commands %}\n',
+            '# End Nl Section: 98\n',
+            '\n',
+            '# Start Nl Section: 100\n',
+            '{% endblock %}\n',
+            '\n',
+            '{% for dependency in dependencies: %}\n',
+            "  {%  if ';' in dependency: %}\n",
+            '{{handle_complex_dependency(dependency)}}\n',
+            '  {%   endif %}\n',
+            '{% endfor %}\n',
+            '\n',
+            '{% if external_module_library %}\n',
+            '# End Nl Section: 100\n',
+            '\n',
+            '# Start Nl Section: 102\n', "    '{{name}}',\n",
+            '# End Nl Section: 102\n',
+            '\n',
+            '# Start Nl Section: 104\n',
+            '{% for source in sources: %}\n',
+            '# End Nl Section: 104\n',
+            '# Start Nl Section: 105\n',
+            '        "{{source}}",\n',
+            '# End Nl Section: 105\n',
+            '# Start Nl Section: 106\n',
+            '{% endfor %}\n',
+            '# End Nl Section: 106\n',
+            '\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 108\n',
+            '{% else %}\n',
+            '# End Nl Section: 108\n',
+            '\n',
+            '# Start Nl Section: 110\n',
+            '{% if extra_dependencies or dependencies: %}\n',
+            '# End Nl Section: 110\n',
+            '\n',
+            '# Start Nl Section: 112\n',
+            '  {% for dependency in extra_dependencies: %}\n',
+            '     {% for key, value in dependency.items(): %}\n',
+            '# End Nl Section: 112\n',
+            '# Start Nl Section: 113\n',
+            '    "{{key}}": {{value}},\n',
+            '# End Nl Section: 113\n',
+            '# Start Nl Section: 114\n',
+            '     {% endfor %}\n',
+            '  {% endfor %}\n',
+            '# End Nl Section: 114\n',
+            '\n',
+            '# Start Nl Section: 116\n',
+            '{% else: %}\n',
+            '# End Nl Section: 116\n',
+            '\n',
+            '# Start Nl Section: 118\n',
+            '{% endif %}\n',
+            '{% endif %}\n',
+            '# End Nl Section: 118\n',
+            '\n',
+            '# Start Nl Section: 120\n',
+            '{% if nowheel %}\n',
+            '# End Nl Section: 120\n',
+            '\n',
+            '# Start Nl Section: 122\n',
+            '{% else %}\n',
+            '# End Nl Section: 122\n',
+            '\n',
+            '# Start Nl Section: 124\n',
+            '{% endif %}\n',
+            '# End Nl Section: 124\n',
+            '# Start Nl Section: 125\n',
+            'GS_COMMAND = ("gs {{name}} v{{release}} " +\n',
+            '# End Nl Section: 125\n',
+            '# Start Nl Section: 126\n',
+            '              "Find {{release}} in ' +
+            'changelog for more details")\n',
+            '# End Nl Section: 126\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 128\n',
+            '            rmtree(os.path.join' +
+            '(HERE, "{{name|replace(\'-\', \'_\')}}.egg-info"))\n',
+            '# End Nl Section: 128\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 130\n',
+            '{% if "tests" is exists %}\n',
+            '# End Nl Section: 130\n',
+            '\n',
+            '# Start Nl Section: 132\n',
+            '{% endif %}\n',
+            '# End Nl Section: 132\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 134\n',
+            '{% if MAINTAINER %}\n',
+            '# End Nl Section: 134\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 136\n',
+            '{% endif %}\n',
+            '# End Nl Section: 136\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 138\n',
+            '{% if external_module_library %}\n',
+            '# End Nl Section: 138\n',
+            '\n',
+            '# Start Nl Section: 140\n',
+            '{% else %}\n',
+            '# End Nl Section: 140\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '\n',
+            '# Start Nl Section: 142\n',
+            '{% if command_line_interface or entry_points %}\n',
+            '# End Nl Section: 142\n',
+            '\n',
+            '# Start Nl Section: 144\n',
+            '{% endif %}\n',
+            '{% endif%}\n',
+            '# End Nl Section: 144\n',
+            '\n',
+            '\n',
+            '\n')
+
+        self.assertEqual(temp_file_dict[uut_temp_file_name], expected_tuple)

From 20652070886c393f8c4962c2917469c83b46415a Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Wed, 21 Aug 2019 20:34:52 +0530
Subject: [PATCH 11/19] NlCliParsing: Add NlCliParsing

This PR adds the NlCliParsing.

NlCliParsing is used to parse the cli arguments and use
the information to create cli_sections just like coala
does when it receives arguments from CLI
---
 coalib/nestedlib/NlCliParsing.py       | 147 +++++++++++++++++++++++++
 coalib/nestedlib/NlFileHandler.py      |  12 +-
 tests/nestedlib/NlCliParsingTest.py    | 112 +++++++++++++++++++
 tests/nestedlib/NlFileHandlerTest.py   |   6 +-
 tests/nestedlib/NlInfoExtractorTest.py |  14 +--
 5 files changed, 275 insertions(+), 16 deletions(-)
 create mode 100755 coalib/nestedlib/NlCliParsing.py
 create mode 100755 tests/nestedlib/NlCliParsingTest.py

diff --git a/coalib/nestedlib/NlCliParsing.py b/coalib/nestedlib/NlCliParsing.py
new file mode 100755
index 000000000..977b8b6de
--- /dev/null
+++ b/coalib/nestedlib/NlCliParsing.py
@@ -0,0 +1,147 @@
+import os
+from argparse import ArgumentParser
+from collections import OrderedDict
+from coalib.nestedlib.NlInfoExtractor import (
+    get_orig_file, get_temp_file_lang)
+from coalib.parsing.LineParser import LineParser
+from coalib.settings.Section import Section, append_to_sections
+from coalib.bearlib import deprecate_settings
+
+
+@deprecate_settings(comment_separators='comment_seperators')
+def parse_nl_cli(args=None,
+                 nl_section_name=None,
+                 nl_info_dict=None,
+                 origin=os.getcwd(),
+                 key_value_delimiters=('=', ':'),
+                 comment_separators=(),
+                 key_delimiters=(',',),
+                 section_override_delimiters=('.',),
+                 key_value_append_delimiters=('+=',)):
+    """
+    Parses the CLI arguments and creates sections out of it.
+
+    :param origin:                      Directory used to interpret relative
+                                        paths given as argument.
+    :param args:                        Alternative pre-parsed CLI arguments.
+    :param key_value_delimiters:        Delimiters to separate key and value
+                                        in setting arguments where settings are
+                                        being defined.
+    :param comment_separators:          Allowed prefixes for comments.
+    :param key_delimiters:              Delimiter to separate multiple keys of
+                                        a setting argument.
+    :param section_override_delimiters: The delimiter to delimit the section
+                                        from the key name (e.g. the '.' in
+                                        sect.key = value).
+    :param key_value_append_delimiters: Delimiters to separate key and value
+                                        in setting arguments where settings are
+                                        being appended.
+    :return:                            A dictionary holding section names
+                                        as keys and the sections themselves
+                                        as value.
+    """
+
+    origin += os.path.sep
+    sections = OrderedDict()
+    sections[nl_section_name] = Section(nl_section_name)
+    line_parser = LineParser(key_value_delimiters,
+                             comment_separators,
+                             key_delimiters,
+                             {},
+                             section_override_delimiters,
+                             key_value_append_delimiters)
+
+    for arg_key, arg_value in sorted(vars(args).items()):
+        if arg_key == 'settings' and arg_value is not None:
+            parse_nl_custom_settings(sections,
+                                     nl_section_name,
+                                     arg_value,
+                                     origin,
+                                     line_parser)
+        else:
+            if isinstance(arg_value, list):
+                arg_value = ','.join([str(val) for val in arg_value])
+
+            append_to_sections(sections,
+                               arg_key,
+                               arg_value,
+                               origin,
+                               section_name=nl_section_name,
+                               from_cli=True)
+
+    temp_file_name = args.__dict__['files']
+    # The following values are necessary to help detect the parser and for
+    # reassembling.
+    # Append the language of the temporary segregated file
+    append_to_sections(sections,
+                       'file_lang',
+                       get_temp_file_lang(nl_info_dict, temp_file_name),
+                       origin=origin,
+                       section_name=nl_section_name,
+                       from_cli=True)
+
+    # Append the name of the original nested file
+    append_to_sections(sections,
+                       'orig_file_name',
+                       get_orig_file(nl_info_dict, temp_file_name),
+                       origin=origin,
+                       section_name=nl_section_name,
+                       from_cli=True)
+
+    return sections
+
+
+def parse_nl_custom_settings(sections,
+                             nl_section_name,
+                             custom_settings_list,
+                             origin,
+                             line_parser):
+    """
+    Parses the custom settings given to coala via ``-S something=value``.
+
+    :param sections:             The Section dictionary to add to (mutable).
+    :param nl_section_name:      The name of the nested language coala section
+    :param custom_settings_list: The list of settings strings.
+    :param origin:               The originating directory.
+    :param line_parser:          The LineParser to use.
+    """
+    for setting_definition in custom_settings_list:
+        (_, key_tuples, value, append, _) = line_parser._parse(
+            setting_definition)
+        for key_tuple in key_tuples:
+            append_to_sections(sections,
+                               key=key_tuple[1],
+                               value=value,
+                               origin=origin,
+                               to_append=append,
+                               section_name=(key_tuple[0] or nl_section_name),
+                               from_cli=True)
+
+
+def check_conflicts(sections):
+    """
+    Checks if there are any conflicting arguments passed.
+
+    :param sections:    The ``{section_name: section_object}`` dictionary to
+                        check conflicts for.
+    :return:            True if no conflicts occur.
+    :raises SystemExit: If there are conflicting arguments (exit code: 2)
+    """
+    for section in sections.values():
+        if (
+                section.get('no_config', False) and
+                (section.get('save', False) or
+                 section.get('find_config', False) or
+                 str(section.get('config', 'input')) != 'input')):
+            ArgumentParser().error(
+                "'no_config' cannot be set together with 'save', "
+                "'find_config' or 'config'.")
+
+        if (
+                not section.get('json', False) and
+                (str(section.get('output', '')) or
+                 section.get('relpath', False))):
+            ArgumentParser().error(
+                "'output' or 'relpath' cannot be used without `--json`.")
+
+    return True
diff --git a/coalib/nestedlib/NlFileHandler.py b/coalib/nestedlib/NlFileHandler.py
index 981d7c02a..5645dfc94 100755
--- a/coalib/nestedlib/NlFileHandler.py
+++ b/coalib/nestedlib/NlFileHandler.py
@@ -198,7 +198,7 @@ def get_preprocessed_nl_sections(all_nl_sections, parser):
     # For eg: In a combination of Python and Jinja, we mark the mixed lang
     # nl_sections with jinja2 since Jinja2Bear can lint through them
     parser_name = parser.__class__.__name__
-    mixed_lang = ""
+    mixed_lang = ''
     for parser_mixed_lang_dict in PARSER_MIXED_LINE_COMB:
         for parser, lang in parser_mixed_lang_dict.items():
             if parser_name.lower() == parser.lower():
@@ -206,7 +206,7 @@ def get_preprocessed_nl_sections(all_nl_sections, parser):
                 break
 
     if not mixed_lang:
-        logging.error("No PARSER_MIXED_LINE_COMB exist")
+        logging.error('No PARSER_MIXED_LINE_COMB exist')
         raise SystemExit(2)
 
     preprocessed_nl_section_index = 1
@@ -217,8 +217,8 @@ def get_preprocessed_nl_sections(all_nl_sections, parser):
 
         nl_section = all_nl_sections[index]
         mixed_lang_section, num_mixed_nl_sections = is_mixed_lang_section(
-                                                  all_nl_sections[index:],
-                                                  nl_section_to_check=nl_section)
+                                            all_nl_sections[index:],
+                                            nl_section_to_check=nl_section)
         if mixed_lang_section:
             mixed_nl_section = deepcopy(nl_section)
             mixed_nl_section.start.column = None
@@ -291,8 +291,8 @@ def (hello):
     # For now this string works for the combination of Python and Jinja
     # When more language support is added, You can use `if` statements to
     # use the proper prefix
-    start_marker_prefix = "# Start Nl Section: "
-    end_marker_prefix = "# End Nl Section: "
+    start_marker_prefix = '# Start Nl Section: '
+    end_marker_prefix = '# End Nl Section: '
 
     # Store the count of number of lines have been added.
     added_lines = 0
diff --git a/tests/nestedlib/NlCliParsingTest.py b/tests/nestedlib/NlCliParsingTest.py
new file mode 100755
index 000000000..e5fc4f735
--- /dev/null
+++ b/tests/nestedlib/NlCliParsingTest.py
@@ -0,0 +1,112 @@
+import unittest
+
+from coalib.parsing.DefaultArgParser import default_arg_parser
+from coalib.nestedlib.NlCliParsing import (parse_nl_cli, check_conflicts)
+
+
+class NlCliParsingTest(unittest.TestCase):
+
+    def setUp(self):
+        self.arg_list = ['--no-config', '--handle-nested',
+                         '--bears=PEP8Bear',
+                         '--languages=python,jinja2',
+                         '--files=test.py_nl_python',
+                         '-S', 'section1.key1,section2.key2=value1,value2',
+                         'section2.key2=only_this_value',
+                         'SECTION2.key2a=k2a',
+                         'invalid.=shouldnt_be_shown',
+                         '.=not_either',
+                         '.key=only_in_cli',
+                         'default_key1,default_key2=single_value',
+                         'default_key3=first_value,second_value']
+
+        self.arg_parser = default_arg_parser()
+        self.args = self.arg_parser.parse_args(self.arg_list)
+        self.nl_info_dict = {
+                'bears': ['PEP8Bear', 'Jinja2Bear'],
+                'files': ['test.py'],
+                'lang_bear_dict': {
+                                    'jinja2': ['Jinja2Bear'],
+                                    'python': ['PEP8Bear']
+                                  },
+                'languages': ['python', 'jinja2'],
+                'nl_file_info': {'test.py': {
+                                                'python': 'test.py_nl_python',
+                                                'jinja2': 'test.py_nl_jinja2'
+                                              },
+                                 }
+                }
+
+    @staticmethod
+    def dict_from_sections(parsed_sections):
+        parsed_dict = {}
+        for section_name, section in parsed_sections.items():
+            parsed_dict[section_name] = (
+                set([(key,
+                      str(value)) for key, value in section.contents.items()]))
+        return parsed_dict
+
+    def test_parse_cli(self):
+        parsed_sections = parse_nl_cli(
+                            args=self.args,
+                            nl_section_name='cli_nl_section: test.py_nl_python',
+                            nl_info_dict=self.nl_info_dict)
+        expected_dict = {
+            'cli_nl_section: test.py_nl_python': {
+                                            ('bears', 'PEP8Bear'),
+                                            ('default_key1', 'single_value'),
+                                            ('default_key2', 'single_value'),
+                                            ('default_key3',
+                                             'first_value,second_value'),
+                                            ('files', 'test.py_nl_python'),
+                                            ('handle_nested', 'True'),
+                                            ('key', 'only_in_cli'),
+                                            ('languages', 'python,jinja2'),
+                                            ('no_config', 'True'),
+                                            ('targets', '')},
+            'section1': {('key1', 'value1,value2')},
+            'section2': {('key2', 'only_this_value'), ('key2a', 'k2a')}}
+
+        self.assertEqual(
+            parsed_sections['cli_nl_section: test.py_nl_python'].name,
+            'cli_nl_section: test.py_nl_python')
+
+        self.maxDiff = None
+        self.assertEqual(self.dict_from_sections(parsed_sections),
+                         expected_dict)
+
+    def test_check_conflicts(self):
+        arg_parser = default_arg_parser()
+
+        arg_list = ['--save', '--no-config']
+        args = arg_parser.parse_args(arg_list)
+        sections = parse_nl_cli(args=args, nl_info_dict=self.nl_info_dict)
+        with self.assertRaisesRegex(SystemExit, '2') as cm:
+            check_conflicts(sections)
+            self.assertEqual(cm.exception.code, 2)
+
+        arg_list = ['--no-config', '-S', 'val=42']
+        args = arg_parser.parse_args(arg_list)
+        sections = parse_nl_cli(args=args, nl_info_dict=self.nl_info_dict)
+        self.assertTrue(check_conflicts(sections))
+
+        arg_list = ['--relpath']
+        args = arg_parser.parse_args(arg_list)
+        sections = parse_nl_cli(args=args, nl_info_dict=self.nl_info_dict)
+        with self.assertRaisesRegex(SystemExit, '2') as cm:
+            check_conflicts(sections)
+            self.assertEqual(cm.exception.code, 2)
+
+        arg_list = ['--output', 'iraiseValueError']
+        args = arg_parser.parse_args(arg_list)
+        sections = parse_nl_cli(args=args, nl_info_dict=self.nl_info_dict)
+        with self.assertRaisesRegex(SystemExit, '2') as cm:
+            check_conflicts(sections)
+            self.assertEqual(cm.exception.code, 2)
+
+        arg_list = ['--no-config', '--config', '.coafile']
+        args = arg_parser.parse_args(arg_list)
+        sections = parse_nl_cli(args=args, nl_info_dict=self.nl_info_dict)
+        with self.assertRaisesRegex(SystemExit, '2') as cm:
+            check_conflicts(sections)
+            self.assertEqual(cm.exception.code, 2)
diff --git a/tests/nestedlib/NlFileHandlerTest.py b/tests/nestedlib/NlFileHandlerTest.py
index c4ca26092..e6862f188 100755
--- a/tests/nestedlib/NlFileHandlerTest.py
+++ b/tests/nestedlib/NlFileHandlerTest.py
@@ -189,9 +189,9 @@ def test_coala_setup_template(self):
             '\n',
             '# Start Nl Section: 3\n',
             '{% endblock %}\n',
-            "{% set min_python_version = " +
+            '{% set min_python_version = ' +
             "min_python_version|default('2.6') %}\n",
-            "{% set min_python_version = " +
+            '{% set min_python_version = ' +
             "min_python_version.split('.', 2) %}\n",
             '\n',
             '{% block header %}\n',
@@ -283,7 +283,7 @@ def test_coala_setup_template(self):
             '\n',
             '# Start Nl Section: 29\n',
             "{% if not entry_points or 'console_scripts' " +
-            "not in entry_points %}\n",
+            'not in entry_points %}\n',
             '# End Nl Section: 29\n',
             '\n',
             '# Start Nl Section: 31\n',
diff --git a/tests/nestedlib/NlInfoExtractorTest.py b/tests/nestedlib/NlInfoExtractorTest.py
index 026f717ce..3a7efa666 100755
--- a/tests/nestedlib/NlInfoExtractorTest.py
+++ b/tests/nestedlib/NlInfoExtractorTest.py
@@ -16,13 +16,13 @@ class NlInfoExtractor(unittest.TestCase):
 
     def setUp(self):
         self.arg_parser = default_arg_parser()
-        self.test_dir_path = os.path.abspath(__file__ + "/../..")
-        self.test_bear_path = os.path.join(self.test_dir_path, "test_bears")
+        self.test_dir_path = os.path.abspath(__file__ + '/../..')
+        self.test_bear_path = os.path.join(self.test_dir_path, 'test_bears')
         # Both the upper case and lower case is supported in `languages`
         # argument
         self.args = self.arg_parser.parse_args([
-                                    '-f', 'test.py.jj2,test2.py.jj2',
-                                    '-b',
+                                '-f', 'test.py.jj2,test2.py.jj2',
+                                '-b',
                                 'PEP8TestBear,Jinja2TestBear,LineCountTestBear',
                                 '--handle-nested', '--languages',
                                 'PYTHON,Jinja2',
@@ -54,9 +54,9 @@ def test_check_lang_support(self):
                 check_lang_support(lang_list)
                 self.assertRegex(
                     cm.output[0],
-                    "The language combination are not supported. "
-                    "Please check if the languages are provided with"
-                    "the correct names")
+                    'The language combination are not supported. '
+                    'Please check if the languages are provided with'
+                    'the correct names')
 
         uut_lang_list = ['PYTHON', 'JiNjA2']
         check_lang_support(uut_lang_list)

From 04404d6785b2a56881ee5a6b56e69a3d9fae6082 Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Thu, 22 Aug 2019 00:31:13 +0530
Subject: [PATCH 12/19] NlCore: Add NlCore

This PR adds NlCore

NlCore is the main core of the entire Nested language
Architecture. This is the class with with the coala
interacts with, to access an functions of Nested language.

This is responsible for creating coala_nl_sections and
writing the selected patches by the user to the original
file.

The coverage was failing for `test_apply_patches_to_nl_file` because
shutil was not being to find the file. This PR mocks the
`write_patches_to_orig_nl_file` function of NlCore.
---
 coalib/nestedlib/NlCore.py    | 359 ++++++++++++++++++++++++++++++++++
 tests/nestedlib/NlCoreTest.py | 298 ++++++++++++++++++++++++++++
 2 files changed, 657 insertions(+)
 create mode 100755 coalib/nestedlib/NlCore.py
 create mode 100755 tests/nestedlib/NlCoreTest.py

diff --git a/coalib/nestedlib/NlCore.py b/coalib/nestedlib/NlCore.py
new file mode 100755
index 000000000..f530eecfa
--- /dev/null
+++ b/coalib/nestedlib/NlCore.py
@@ -0,0 +1,359 @@
+from coalib.nestedlib.NlInfoExtractor import generate_arg_list
+from coalib.parsing.DefaultArgParser import default_arg_parser
+from coalib.nestedlib.NlCliParsing import parse_nl_cli
+from collections import OrderedDict
+from importlib import import_module
+
+from coalib.parsing.DefaultArgParser import default_arg_parser
+import logging
+from copy import deepcopy
+from coalib.settings.Setting import glob_list
+import shutil
+from coala_utils.FileUtils import detect_encoding
+
+
+# The supported Parser for the language combination
+PARSER_LANG_COMB = [{'PyJinjaParser': {'python', 'jinja2'}}]
+
+
+def get_parser(lang_comb):
+    """
+    Return the parser object for the combination of the languages
+    """
+    lang_comb = set(lang_comb.split(','))
+    parser_name = ''
+
+    for parser_lang_comb in PARSER_LANG_COMB:
+        for parser, language in parser_lang_comb.items():
+            if language == lang_comb:
+                parser_name = parser
+
+    parser_module_string = ('coalib.nestedlib.parsers.' + parser_name)
+    try:
+        parser = getattr(import_module(parser_module_string), parser_name)
+    except ModuleNotFoundError:
+        logging.error('No Parser found for the languages combination')
+        raise SystemExit(2)
+
+    return parser()
+
+
+def get_nl_coala_sections(args=None, arg_list=None, arg_parser=None):
+    """
+    Generate the coala sections for all the nested languages.
+    """
+    assert not (arg_list and args), (
+        'Either call parse_cli() with an arg_list of CLI arguments or '
+        'with pre-parsed args, but not with both.')
+
+    if args is None:
+        arg_parser = default_arg_parser() if arg_parser is None else arg_parser
+        args = arg_parser.parse_args(arg_list)
+
+    arg_list, nl_info_dict = generate_arg_list(args)
+    nl_sections = OrderedDict()
+    for args in arg_list:
+        temp_file_name = args.__dict__['files']
+        nl_section_name = 'cli_nl_section: ' + temp_file_name
+        sections = parse_nl_cli(args=args,
+                                nl_section_name=nl_section_name,
+                                nl_info_dict=nl_info_dict)
+        nl_sections[nl_section_name] = sections[nl_section_name]
+
+    return nl_sections
+
+
+def nested_language(args=None, arg_list=None, arg_parser=None):
+    """
+    Check if handle_nested condition is present in arguments
+    """
+    handle_nested = False
+    # If args is None check if arg_list has handle_nested.
+    if args is None:
+        arg_parser = default_arg_parser() if arg_parser is None else arg_parser
+        nested_args = arg_parser.parse_args(arg_list)
+        if nested_args.handle_nested:
+            handle_nested = True
+    else:
+        if args.handle_nested:
+            handle_nested = True
+
+    return handle_nested
+
+
+def get_temp_file_content(nl_file_dicts, temp_file_name):
+    """
+    Get the temp file dict of temp_file_name from the patched
+    nl_file_dicts.
+
+    If you a nested file `test.py` which contains python and jinja as the
+    nested language, then the
+
+    nl_file_dicts looks something like this:
+
+    ```
+    {
+        'cli_nl_section: test.py_nl_python':
+            {'test.py_nl_python': ['!!! Start Nl Section: 1\n', '\n', '\n',
+                                    'def hello():\n', '\n', '\n',
+                                    '!!! End Nl Section: 1\n', '\n', '\n',
+                                  ]},
+
+        'cli_nl_section: test.py_nl_jinja2':
+            {'test.py_nl_jinja2': ['\n',
+                                   '!!! Start Nl Section: 2\n',
+                                   '    {{ x }} asdasd {{ Asd }}\n',
+                                   '!!! End Nl Section: 2\n',
+                                   ]},
+    }
+    ```
+    """
+    temp_file_content = {}
+    for nl_coala_section, temp_file in nl_file_dicts.items():
+        for filename, file_content in temp_file.items():
+            if temp_file_name == filename:
+                temp_file_content = file_content
+                break
+    return temp_file_content
+
+
+def remove_position_markers(temp_file_content):
+    """
+    Remove the position markers from the line.
+
+    Return a dicitionary where the key is the section index and the value
+    is the content of the section index.
+
+    We we encounter a `Start Nl Section` string, we extract the index from
+    it and keep appending all the lines into a lines_list until we reach the
+    `End Nl Section` string of the same index. Then we make a dictionary
+    with the key as the section index and the value as the list of lines
+    that were present inside the section.
+
+    For eg:
+
+    Input -
+    ```
+    ['!!! Start Nl Section: 1\n', '\n', '\n',
+    'def hello():\n',
+    '!!! End Nl Section: 1\n', '\n',
+    ]
+    ```
+
+    The output we receive is:
+    ```
+    {1: ['\n', '\n', def hello():\n', '\n']}
+    ```
+
+    """
+    section_index_lines_dict = {}
+    section_index = None
+    append_lines = False
+    line_list = []
+
+    for line in temp_file_content:
+
+        if 'Start Nl Section: ' in line:
+            section_index = int(line.split(': ')[1])
+            append_lines = True
+            continue
+
+        elif 'End Nl Section: ' in line:
+            section_index_lines_dict[section_index] = deepcopy(line_list)
+            append_lines = False
+            section_index = None
+            line_list.clear()
+
+        if append_lines:
+            line_list.append(line)
+
+    return section_index_lines_dict
+
+
+def get_linted_file_sections(nl_file_dicts, nl_file_info_dict):
+    """
+    Generate the linted file dict for every original file.
+
+    This dictionary contains section_index as the key and the content
+    in those sections as the value.
+
+    We'll get the file_dict of the temporary files of each original file,
+    process the file dict to remove the position markers and then create a
+    new file dictionary, where we store the key as the section index and the
+    content of that section as it's value.
+
+    Something like:
+
+    {'test.py': {
+                    1: [ 'def hello(): \n' ] ,
+                    2: [  '\n', '\n'],
+                    3: [ '    {{ x }} asdasd {{ Asd }}\n ],
+                    4: [ '{{ x }}\n']
+                }
+    }
+
+
+    nl_info_dict = { 'test.py' : {
+                                        'python' : 'test.py_nl_python',
+                                        'jinja2' : 'test.py_nl_jinja2'
+                                 },
+
+                      'test2.py': {
+                                        'python' : 'test2.py_nl_python',
+                                        'jinja2' : 'test2.py_nl_jinja2'
+                                  }
+                   }
+    """
+
+    file_dicts = {}
+
+    for orig_file, temp_file_info in nl_file_info_dict.items():
+        for lang, temp_filename in temp_file_info.items():
+            temp_file_content = get_temp_file_content(nl_file_dicts,
+                                                      temp_filename)
+
+            # PostProcess the lines to remove the position markers
+            # Generate a dict which has the key as the section index
+            # and the value as the content of the section. This will
+            # help in assembling.
+            section_index_lines = remove_position_markers(
+                                                    temp_file_content)
+            if not file_dicts.get(orig_file):
+                file_dicts[orig_file] = section_index_lines
+            else:
+                file_dicts[orig_file].update(section_index_lines)
+
+    return file_dicts
+
+
+def generate_linted_file_dict(nl_file_dicts, nl_file_info_dict):
+    """
+    Generate a dict with the orig_filename as the key and the value as the
+    file contents of the file.
+
+    Use the section indexes present in the original_file_dict to assemble
+    all the sections and generate the actual linted file.
+
+    Linted file looks like:
+    {'test.py': {
+                    1: [ 'def hello(): \n' ] ,
+                    2: [  '\n', '\n'],
+                    3: [ '    {{ x }} asdasd {{ Asd }}\n ],
+                    4: [ '{{ x }}\n']
+                },
+     'test2.py':{
+                    1: ['print("Hello Homosapiens")'],
+                    2: ['{% set x = {{var}} %}']
+                }
+    }
+
+    The sections are sorted according to their index and their content
+    are combined to make one list. This list will then be written into a file.
+
+    {'test.py':  [ 'def hello(): \n',
+                   '\n',
+                   '\n',
+                   '    {{ x }} asdasd {{ Asd }}\n ,
+                   '{{ x }}\n'
+                 ],
+
+     'test2.py': [ 'print("Hello Homosapiens")',
+                   '{% set x = {{var}} %}'
+                 ]
+
+    }
+
+    """
+    linted_file_dict = {}
+    linted_file_sections = get_linted_file_sections(
+        nl_file_dicts, nl_file_info_dict)
+    for file, section_line_dict in linted_file_sections.items():
+        # Create an entry for the file, if it's not already present.
+        # Useful when we pass multiple files in `--files` argument.
+        linted_file_dict[file] = []
+        for section_index in sorted(section_line_dict):
+            section_content = section_line_dict[section_index]
+            linted_file_dict[file].extend(section_content)
+
+    return linted_file_dict
+
+
+def write_patches_to_orig_nl_file(linted_file_dict, sections):
+    """
+    Update the original Nested language file with the patches that the user
+    chose to apply.
+
+    We create a backup with the extension of `.orig` similar to how coala
+    does when it writes the patches to the file.
+    """
+    for filename, patched_filecontent in linted_file_dict.items():
+        orig_file_path = get_original_file_path(sections, filename)
+        # Backup original file
+        shutil.copy2(orig_file_path, orig_file_path + '.orig')
+
+        with open(orig_file_path, mode='w',
+                  encoding=detect_encoding(orig_file_path)) as file:
+            file.writelines(patched_filecontent)
+
+    return
+
+
+def get_original_file_path(sections, filename):
+    """
+    Return the path where the file is located.
+    """
+    file_path = ''
+    for section_name in sections:
+        section = sections[section_name]
+        if str(section.get('orig_file_name')) == filename:
+            file_path = glob_list(section.get('orig_file_name', ''))[0]
+            break
+    return file_path
+
+
+def apply_patches_to_nl_file(nl_file_dicts, sections, args=None,
+                             arg_list=None, nl_info_dict=None,
+                             arg_parser=None):
+    """
+    :param nl_file_dicts: The linted nested language file dict
+    :param sections     : The coala nl sections
+    :param args         : The args passed in via CLI
+    :parma arg_list     : The arg_list that contains precompiled args
+    :param nl_info_dict : The dicitionary which contains the info of
+                          the original file name as the key and the
+                          value as the information about the temporary
+                          file and the language.
+
+    Write the accepted patches into the original nested language file.
+
+    We assemble the applied patches from all the temporary linted pure
+    language file and preprocess it to remove the `nl section position`
+    markers and then write it to the original file.
+
+    We can use the generate_arg_list function to get more information about
+    the original file and temporary file.
+    'nl_file_info': {   'test.py' : {
+                                        'python' : 'test.py_nl_python',
+                                        'jinja2' : 'test.py_nl_jinja2'
+                                    },
+
+                        'test2.py': {
+                                        'python' : 'test2.py_nl_python',
+                                        'jinja2' : 'test2.py_nl_jinja2'
+                                    }
+                    }
+    """
+
+    if args is None:
+        arg_parser = default_arg_parser() if arg_parser is None else arg_parser
+        args = arg_parser.parse_args(arg_list)
+
+    if not nl_info_dict:
+        arg_list, nl_info_dict = generate_arg_list(args)
+    nl_file_info_dict = nl_info_dict['nl_file_info']
+
+    linted_file_dict = generate_linted_file_dict(nl_file_dicts,
+                                                 nl_file_info_dict)
+    write_patches_to_orig_nl_file(linted_file_dict, sections)
+
+    return linted_file_dict
diff --git a/tests/nestedlib/NlCoreTest.py b/tests/nestedlib/NlCoreTest.py
new file mode 100755
index 000000000..18f1750d2
--- /dev/null
+++ b/tests/nestedlib/NlCoreTest.py
@@ -0,0 +1,298 @@
+import os
+import unittest
+import logging
+from unittest import mock
+from coalib.parsing.DefaultArgParser import default_arg_parser
+
+from coalib.nestedlib.NlCore import (get_parser,
+                                     get_nl_coala_sections,
+                                     nested_language,
+                                     remove_position_markers,
+                                     get_temp_file_content,
+                                     generate_linted_file_dict,
+                                     get_original_file_path,
+                                     apply_patches_to_nl_file)
+from coalib.nestedlib.parsers.PyJinjaParser import PyJinjaParser
+from coalib.nestedlib.NlInfoExtractor import generate_arg_list
+
+
+class NlCoreTest(unittest.TestCase):
+
+    def setUp(self):
+        self.arg_parser = default_arg_parser()
+        self.test_dir_path = os.path.abspath(__file__ + '/../..')
+        self.test_bear_path = os.path.join(self.test_dir_path, 'test_bears')
+        self.arg_list = ['--no-config', '--handle-nested',
+                         '--bears=PEP8TestBear,Jinja2TestBear',
+                         '--languages=python,jinja2', '--files=test.py',
+                         '--bear-dirs='+self.test_bear_path
+                         ]
+        self.args = self.arg_parser.parse_args(self.arg_list)
+
+    def test_get_parser_PyJinjaParser(self):
+        uut_lang_comb = 'python,jinja2'
+        parser = get_parser(uut_lang_comb)
+        assert isinstance(parser, PyJinjaParser)
+
+        # Test for parser not found
+        uut_lang_comb = 'python,cpp'
+        logger = logging.getLogger()
+        with self.assertLogs(logger, 'ERROR') as cm:
+            with self.assertRaises(SystemExit):
+                parser = get_parser(uut_lang_comb)
+                self.assertRegex(
+                    cm.output[0],
+                    'No Parser found for the languages combination')
+
+    def test_get_nl_coala_sections(self):
+
+        self.maxDiff = None
+        uut_nl_sections = get_nl_coala_sections(args=self.args)
+        self.assertEqual(
+            str(uut_nl_sections['cli_nl_section: test.py_nl_python']),
+            "cli_nl_section: test.py_nl_python {targets : '', " +
+            "bear_dirs : '" + self.test_bear_path + "', " +
+            "bears : 'PEP8TestBear', files : 'test.py_nl_python', " +
+            "handle_nested : 'True', languages : 'python,jinja2', " +
+            "no_config : 'True', file_lang : 'python', " +
+            "orig_file_name : 'test.py'}")
+
+        # When arg_list is passed
+        uut_nl_sections = get_nl_coala_sections(arg_list=self.arg_list)
+        self.assertEqual(
+            str(uut_nl_sections['cli_nl_section: test.py_nl_python']),
+            "cli_nl_section: test.py_nl_python {targets : '', " +
+            "bear_dirs : '" + self.test_bear_path + "', " +
+            "bears : 'PEP8TestBear', files : 'test.py_nl_python', " +
+            "handle_nested : 'True', languages : 'python,jinja2', " +
+            "no_config : 'True', file_lang : 'python', " +
+            "orig_file_name : 'test.py'}")
+
+    def test_nested_language(self):
+        # When --handle-nested is present
+        handle_nested = nested_language(args=self.args)
+        self.assertTrue(handle_nested)
+
+        # When --handle-nested is passed via arg_list
+        handle_nested = nested_language(arg_list=self.arg_list)
+        self.assertTrue(handle_nested)
+
+        # When --handle-nested is not present
+        handle_nested = nested_language(arg_list=[])
+        self.assertFalse(handle_nested)
+
+    def test_get_temp_file_content(self):
+        nl_file_dicts = {
+            'cli_nl_section: test.py_nl_python':
+                {'test.py_nl_python': ['!!! Start Nl Section: 1\n', '\n', '\n',
+                                       'def hello():\n', '\n', '\n',
+                                       '!!! End Nl Section: 1\n', '\n', '\n',
+                                       ]},
+
+            'cli_nl_section: test.py_nl_jinja2':
+                {'test.py_nl_jinja2': ['\n',
+                                       '!!! Start Nl Section: 2\n',
+                                       '    {{ x }} asdasd {{ Asd }}\n',
+                                       '!!! End Nl Section: 2\n',
+                                       ]},
+        }
+
+        uut_temp_file_name = 'test.py_nl_python'
+        expected_file_content = ['!!! Start Nl Section: 1\n', '\n', '\n',
+                                 'def hello():\n', '\n', '\n',
+                                 '!!! End Nl Section: 1\n', '\n', '\n',
+                                 ]
+
+        file_content = get_temp_file_content(nl_file_dicts,
+                                             uut_temp_file_name)
+
+        self.assertEqual(expected_file_content, file_content)
+
+    def test_remove_position_markers(self):
+
+        uut_temp_file_contents = ['!!! Start Nl Section: 1\n',
+                                  '\n',
+                                  'print("Hello world")\n',
+                                  'def hello():\n',
+                                  '\n',
+                                  '!!! End Nl Section: 1\n',
+                                  '\n']
+
+        expected_output = {1: ['\n',
+                               'print("Hello world")\n',
+                               'def hello():\n',
+                               '\n'
+                               ]
+                           }
+
+        section_index_lines_dict = remove_position_markers(
+                                            uut_temp_file_contents)
+
+        self.assertEqual(expected_output, section_index_lines_dict)
+
+    def test_generate_linted_file_dict(self):
+        linted_temp_nl_file_dicts = {
+            'cli_nl_section: test.py_nl_python':
+                {'test.py_nl_python': ['!!! Start Nl Section: 1\n',
+                                       'def hello():\n',
+                                       '\n',
+                                       '\n',
+                                       '!!! End Nl Section: 1\n',
+                                       '\n',
+                                       '\n',
+                                       ]},
+
+            'cli_nl_section: test.py_nl_jinja2':
+                {'test.py_nl_jinja2': ['\n',
+                                       '!!! Start Nl Section: 2\n',
+                                       '    {{ x }} asdasd {{ Asd }}\n',
+                                       '!!! End Nl Section: 2\n',
+                                       ]},
+
+            'cli_nl_section: test2.py_nl_python':
+                {'test2.py_nl_python': ['!!! Start Nl Section: 1\n',
+                                        'print("Hello Thanos)\n',
+                                        '!!! End Nl Section: 1\n',
+                                        ]},
+
+            'cli_nl_section: test2.py_nl_jinja2':
+                {'test2.py_nl_jinja2': ['\n',
+                                        '!!! Start Nl Section: 2',
+                                        '{% set x = {{var}} %}\n',
+                                        '!!! End Nl Section: 2\n',
+                                        ]},
+
+        }
+
+        nl_file_info_dict = {'test.py': {
+                                        'python': 'test.py_nl_python',
+                                        'jinja2': 'test.py_nl_jinja2'
+                                         },
+
+                             'test2.py': {
+                                        'python': 'test2.py_nl_python',
+                                        'jinja2': 'test2.py_nl_jinja2'
+                                      }
+                             }
+
+        expected_ouput = {
+                'test.py': ['def hello():\n',
+                            '\n',
+                            '\n',
+                            '    {{ x }} asdasd {{ Asd }}\n',
+                            ],
+
+                'test2.py': ['print("Hello Thanos)\n',
+                             '{% set x = {{var}} %}\n'
+                             ]
+
+            }
+
+        linted_file_dict = generate_linted_file_dict(
+                                            linted_temp_nl_file_dicts,
+                                            nl_file_info_dict)
+
+        self.assertEqual(expected_ouput, linted_file_dict)
+
+    def test_get_original_file_path(self):
+
+        config_path = os.path.abspath(os.path.dirname(__file__))
+
+        # When the filename is present in nl section
+        os.path.join(config_path, 'test.py')
+
+        uut_arg_list = ['--no-config', '--handle-nested',
+                        '--bears=PEP8TestBear,Jinja2TestBear',
+                        '--languages=python,jinja2',
+                        '--files=test.py',
+                        '--bear-dirs='+self.test_bear_path
+                        ]
+        uut_args = self.arg_parser.parse_args(uut_arg_list)
+        uut_nl_sections = get_nl_coala_sections(uut_args)
+        file_path = get_original_file_path(uut_nl_sections, 'test.py')
+        expected_file_path = os.path.join(
+            os.path.abspath(os.path.dirname(__file__) + '/../..'), 'test.py')
+        self.assertEqual(expected_file_path, file_path)
+
+        # When the filename is not present in nl section
+        os.path.join(config_path, 'test2.py')
+
+        uut_arg_list = ['--no-config', '--handle-nested',
+                        '--bears=PEP8TestBear,Jinja2TestBear',
+                        '--languages=python,jinja2',
+                        '--files=test2.py',
+                        '--bear-dirs='+self.test_bear_path
+                        ]
+        uut_args = self.arg_parser.parse_args(uut_arg_list)
+        uut_nl_sections = get_nl_coala_sections(uut_args)
+        file_path = get_original_file_path(uut_nl_sections, 'test.py')
+        expected_file_path = ''
+        self.assertEqual(expected_file_path, file_path)
+
+    def test_apply_patches_to_nl_file(self):
+        # The path for test file
+
+        linted_temp_nl_file_dicts = {
+            'cli_nl_section: test.py_nl_python':
+            {'test.py_nl_python': ['!!! Start Nl Section: 1\n',
+                                   'print("Hello Thanos")\n',
+                                   '!!! End Nl Section: 1\n',
+                                   ]},
+
+            'cli_nl_section: test.py_nl_jinja2':
+            {'test.py_nl_jinja2': ['\n',
+                                   '!!! Start Nl Section: 2',
+                                   '{% set x = {{var}} %}\n',
+                                   '!!! End Nl Section: 2\n',
+                                   ]}
+            }
+
+        uut_arg_list = ['--no-config', '--handle-nested',
+                        '--bears=PEP8TestBear,Jinja2TestBear',
+                        '--languages=python,jinja2',
+                        '--files=test.py',
+                        '--bear-dirs='+self.test_bear_path
+                        ]
+
+        uut_args = self.arg_parser.parse_args(uut_arg_list)
+        uut_nl_sections = get_nl_coala_sections(uut_args)
+
+        expected_linted_file_dict = {'test.py':
+                                     ['print("Hello Thanos")\n',
+                                      '{% set x = {{var}} %}\n']}
+
+        import_path = 'coalib.nestedlib.NlCore.write_patches_to_orig_nl_file'
+
+        # When args and nl_info_dict is None
+        with mock.patch(
+                import_path,
+                return_value=expected_linted_file_dict) as write_patches_func:
+            linted_file_dict = apply_patches_to_nl_file(
+                nl_file_dicts=linted_temp_nl_file_dicts,
+                sections=uut_nl_sections,
+                arg_list=uut_arg_list,
+                args=None,
+                nl_info_dict=None)
+
+            self.assertEqual(write_patches_func.call_count, 1)
+
+            self.assertEqual(expected_linted_file_dict,
+                             linted_file_dict)
+
+        # Another tests where args and nl_info_dict is not none
+        uut_args = self.arg_parser.parse_args(uut_arg_list)
+        uut_arg_list, uut_nl_info_dict = generate_arg_list(uut_args)
+
+        with mock.patch(
+                import_path,
+                return_value=expected_linted_file_dict) as write_patches_func:
+            linted_file_dict = apply_patches_to_nl_file(
+                nl_file_dicts=linted_temp_nl_file_dicts,
+                sections=uut_nl_sections,
+                args=uut_args,
+                nl_info_dict=uut_nl_info_dict)
+
+            self.assertEqual(write_patches_func.call_count, 1)
+
+            self.assertEqual(expected_linted_file_dict,
+                             linted_file_dict)

From 8f45c52ae199ad7dbd08b37c67a809243b2d06d8 Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Thu, 22 Aug 2019 00:58:32 +0530
Subject: [PATCH 13/19] coala_main: Add NestedLanguage Support

This PR adds the support for nested language mode.
The patches selected by the user in nested language
mode is now passed onto NlCore to replace the old
content of the original nested language file with
the patched version.

coalaTest - Add tests for Nl Mode
---
 coalib/coala_main.py | 29 +++++++++++++++++++++++++----
 tests/coalaTest.py   | 26 ++++++++++++++++++++++++++
 2 files changed, 51 insertions(+), 4 deletions(-)
 mode change 100644 => 100755 coalib/coala_main.py
 mode change 100644 => 100755 tests/coalaTest.py

diff --git a/coalib/coala_main.py b/coalib/coala_main.py
old mode 100644
new mode 100755
index 5c4cdcf54..61118f020
--- a/coalib/coala_main.py
+++ b/coalib/coala_main.py
@@ -25,6 +25,8 @@
 from coalib.parsing.FilterHelper import (
     apply_filters, collect_filters, InvalidFilterException)
 
+from coalib.nestedlib.NlCore import nested_language, apply_patches_to_nl_file
+
 
 def do_nothing(*args):
     return True
@@ -137,6 +139,7 @@ def run_coala(console_printer=None,
     sections = {}
     results = {}
     file_dicts = {}
+    nl_file_dicts = {}
     try:
         yielded_results = yielded_unfixed_results = False
         did_nothing = True
@@ -145,18 +148,28 @@ def run_coala(console_printer=None,
             arg_parser=arg_parser,
             arg_list=arg_list,
             args=args)
-
         logging.debug('Platform {} -- Python {}, coalib {}'
                       .format(platform.system(), platform.python_version(),
                               VERSION))
 
         settings_hash = get_settings_hash(sections, targets)
-        flush_cache = bool(sections['cli'].get('flush_cache', False) or
-                           settings_changed(None, settings_hash))
 
-        if cache is None and not sections['cli'].get('disable_caching', False):
+        if nested_language(args=args, arg_list=arg_list, arg_parser=arg_parser):
+            # Since all the nl_coala_sections have the same settings values
+            # We choose the first sections and get the setting values from it.
+            nl_section = list(sections.values())[0]
+            flush_cache = bool(nl_section.get('flush_cache', False) or
+                               settings_changed(None, settings_hash))
             cache = FileDictFileCache(None, os.getcwd(), flush_cache)
 
+        else:
+            flush_cache = bool(sections['cli'].get('flush_cache', False) or
+                               settings_changed(None, settings_hash))
+
+            if cache is None and not sections['cli'].get('disable_caching',
+                                                         False):
+                cache = FileDictFileCache(None, os.getcwd(), flush_cache)
+
         if targets:
             sections = OrderedDict(
                 (section_name, sections[section_name])
@@ -205,6 +218,14 @@ def run_coala(console_printer=None,
             did_nothing = False
 
             file_dicts[section_name] = section_result[3]
+            nl_file_dicts[section_name] = section_result[4]
+
+        if nested_language(args=args, arg_list=arg_list, arg_parser=arg_parser):
+            apply_patches_to_nl_file(nl_file_dicts=nl_file_dicts,
+                                     args=args,
+                                     arg_list=arg_list,
+                                     arg_parser=arg_parser,
+                                     sections=sections)
 
         update_settings_db(None, settings_hash)
         if cache:
diff --git a/tests/coalaTest.py b/tests/coalaTest.py
old mode 100644
new mode 100755
index 5b43b1ae4..7aa516bd8
--- a/tests/coalaTest.py
+++ b/tests/coalaTest.py
@@ -14,6 +14,7 @@
 from coala_utils.ContextManagers import (
     make_temp, retrieve_stdout, simulate_console_inputs)
 
+
 from tests.TestUtilities import (
     bear_test_module,
     execute_coala,
@@ -416,3 +417,28 @@ def test_coala_ignore_file(self):
                 self.assertEqual(stdout, 'Executing section cli...\n')
                 self.assertEqual(retval, 0, 'coala must return zero when '
                                  'there are no errors')
+
+    def test_nested_language_run_coala(self):
+        # If the nested language file has no error to lint, then the
+        # exit code is zero
+        config_path = os.path.abspath(os.path.join(
+            os.path.dirname(__file__),
+            'processes/section_executor_test_files'))
+
+        testcode_p_path = os.path.join(config_path, 'test.py')
+        uut_arg_list = [
+                        '--no-config', '--handle-nested',
+                        '--bears=PEP8TestBear,Jinja2TestBear',
+                        '--languages=python,jinja2',
+                        '--files='+testcode_p_path,
+                      ]
+        results, retval, _ = run_coala(
+                                        console_printer=ConsolePrinter(),
+                                        log_printer=LogPrinter(),
+                                        arg_list=uut_arg_list,
+                                        autoapply=False,
+                                        )
+
+        self.assertNotEqual(retval, 0,
+                            'coala must return nonzero when '
+                            'errors occured')

From 42a8470e1da5861b859e98e8cd2209a709e41c77 Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Thu, 22 Aug 2019 01:13:42 +0530
Subject: [PATCH 14/19] ConsoleInteraction: Add support for Nested langs

This PR adds the support for nested languages mode in
ConsoleInteraction.py. The function have been updated
to pass the nl_file_dict where the patches chosen by
the user will be applied.

We have also disabled printing the affected files in
Nested Language Mode, since we do not physically have
these files in the system.
---
 coalib/output/ConsoleInteraction.py    | 95 ++++++++++++++++++--------
 tests/output/ConsoleInteractionTest.py | 70 +++++++++++++++++++
 2 files changed, 135 insertions(+), 30 deletions(-)
 mode change 100644 => 100755 coalib/output/ConsoleInteraction.py
 mode change 100644 => 100755 tests/output/ConsoleInteractionTest.py

diff --git a/coalib/output/ConsoleInteraction.py b/coalib/output/ConsoleInteraction.py
old mode 100644
new mode 100755
index 3bf1a7400..548a83494
--- a/coalib/output/ConsoleInteraction.py
+++ b/coalib/output/ConsoleInteraction.py
@@ -150,7 +150,8 @@ def acquire_actions_and_apply(console_printer,
                               result,
                               file_dict,
                               cli_actions=None,
-                              apply_single=False):
+                              apply_single=False,
+                              nl_file_dict=None):
     """
     Acquires applicable actions and applies them.
 
@@ -196,7 +197,8 @@ def acquire_actions_and_apply(console_printer,
             file_diff_dict,
             file_dict,
             applied_actions,
-            apply_single=apply_single
+            apply_single=apply_single,
+            nl_file_dict=nl_file_dict
         )
         if not continue_interaction:
             break
@@ -262,7 +264,8 @@ def print_result(console_printer,
                  result,
                  file_dict,
                  interactive=True,
-                 apply_single=False):
+                 apply_single=False,
+                 nl_file_dict=None):
     """
     Prints the result to console.
 
@@ -326,7 +329,8 @@ def print_result(console_printer,
                                   result,
                                   file_dict,
                                   cli_actions,
-                                  apply_single=apply_single)
+                                  apply_single=apply_single,
+                                  nl_file_dict=nl_file_dict)
 
 
 def print_diffs_info(diffs, printer):
@@ -415,7 +419,8 @@ def print_bears_formatted(bears, format=None):
 def print_affected_files(console_printer,
                          log_printer,
                          result,
-                         file_dict):
+                         file_dict,
+                         nl_file_dict=None):
     """
     Prints all the affected files and affected lines within them.
 
@@ -425,14 +430,20 @@ def print_affected_files(console_printer,
     :param file_dict:       A dictionary containing all files with filename as
                             key.
     """
+    # Print the file not found warning message only when file is not found
+    # in normal coala mode.
+    # In Nested Language mode, physical files does not exist
+    if nl_file_dict:
+        return
+
     if len(result.affected_code) == 0:
         console_printer.print('\n' + STR_PROJECT_WIDE,
                               color=FILE_NAME_COLOR)
     else:
         for sourcerange in result.affected_code:
             if (
-                    sourcerange.file is not None and
-                    sourcerange.file not in file_dict):
+                    (sourcerange.file is not None and
+                     sourcerange.file not in file_dict)):
                 logging.warning('The context for the result ({}) cannot '
                                 'be printed because it refers to a file '
                                 "that doesn't seem to exist ({})"
@@ -449,7 +460,8 @@ def print_results_no_input(log_printer,
                            file_dict,
                            file_diff_dict,
                            console_printer,
-                           apply_single=False):
+                           apply_single=False,
+                           nl_file_dict=None):
     """
     Prints all non interactive results in a section
 
@@ -477,7 +489,8 @@ def print_results_no_input(log_printer,
                      result,
                      file_dict,
                      interactive=False,
-                     apply_single=apply_single)
+                     apply_single=apply_single,
+                     nl_file_dict=nl_file_dict)
 
 
 def print_results(log_printer,
@@ -486,7 +499,8 @@ def print_results(log_printer,
                   file_dict,
                   file_diff_dict,
                   console_printer,
-                  apply_single=False):
+                  apply_single=False,
+                  nl_file_dict=None):
     """
     Prints all the results in a section.
 
@@ -506,14 +520,16 @@ def print_results(log_printer,
         print_affected_files(console_printer,
                              None,
                              result,
-                             file_dict)
+                             file_dict,
+                             nl_file_dict=nl_file_dict)
 
         print_result(console_printer,
                      section,
                      file_diff_dict,
                      result,
                      file_dict,
-                     apply_single=apply_single)
+                     apply_single=apply_single,
+                     nl_file_dict=nl_file_dict)
 
 
 def print_affected_lines(console_printer, file_dict, sourcerange):
@@ -684,6 +700,7 @@ def choose_action(console_printer, actions, apply_single=False):
             if not choice:
                 actions_desc.append(DoNothingAction().get_metadata().desc)
                 actions_name.append(DoNothingAction().get_metadata().name)
+
             return (actions_desc, actions_name)
 
 
@@ -697,7 +714,8 @@ def try_to_apply_action(action_name,
                         result,
                         file_diff_dict,
                         file_dict,
-                        applied_actions):
+                        applied_actions,
+                        nl_file_dict=None):
     """
     Try to apply the given action.
 
@@ -720,21 +738,35 @@ def try_to_apply_action(action_name,
     :param file_dict:       Dictionary with filename as keys and its contents
                             as values.
     """
+
+    # Ignore the actions that are not yet supported in Nested Language
+    # Mode
+
     try:
-        chosen_action.apply_from_section(result,
-                                         file_dict,
-                                         file_diff_dict,
-                                         section)
-        if not isinstance(chosen_action, DoNothingAction):
-            console_printer.print(
-                format_lines(chosen_action.SUCCESS_MESSAGE, symbol='['),
-                color=SUCCESS_COLOR)
-        applied_actions[action_name] = [copy.copy(result), copy.copy(
-            file_dict),
-                                    copy.copy(file_diff_dict),
-                                    copy.copy(section)]
-        result.set_applied_actions(applied_actions)
-        failed_actions.discard(action_name)
+        if(section.get('handle_nested', False) and
+                isinstance(chosen_action, (OpenEditorAction,
+                                           GeneratePatchesAction))):
+            exception = ('{} is not yet supported in Nested Language Mode'.
+                         format(action_name))
+            raise Exception(exception)
+
+        else:
+            chosen_action.apply_from_section(result,
+                                             file_dict,
+                                             file_diff_dict,
+                                             section,
+                                             nl_file_dict=nl_file_dict)
+            if not isinstance(chosen_action, DoNothingAction):
+                console_printer.print(
+                    format_lines(chosen_action.SUCCESS_MESSAGE, symbol='['),
+                    color=SUCCESS_COLOR)
+            applied_actions[action_name] = [copy.copy(result), copy.copy(
+                file_dict),
+                                        copy.copy(file_diff_dict),
+                                        copy.copy(section)]
+            result.set_applied_actions(applied_actions)
+            failed_actions.discard(action_name)
+
     except Exception as exception:  # pylint: disable=broad-except
         logging.error('Failed to execute the action {} with error: {}.'
                       .format(action_name, exception))
@@ -750,7 +782,8 @@ def ask_for_action_and_apply(console_printer,
                              file_diff_dict,
                              file_dict,
                              applied_actions,
-                             apply_single=False):
+                             apply_single=False,
+                             nl_file_dict=None):
     """
     Asks the user for an action and applies it.
 
@@ -800,7 +833,8 @@ def ask_for_action_and_apply(console_printer,
                                     result,
                                     file_diff_dict,
                                     file_dict,
-                                    applied_actions)
+                                    applied_actions,
+                                    nl_file_dict=nl_file_dict)
         return False
     else:
         for action_choice, action_choice_name in zip(actions_desc,
@@ -821,7 +855,8 @@ def ask_for_action_and_apply(console_printer,
                                         result,
                                         file_diff_dict,
                                         file_dict,
-                                        applied_actions)
+                                        applied_actions,
+                                        nl_file_dict=nl_file_dict)
 
             if action_choice == 'Do (N)othing':
                 return False
diff --git a/tests/output/ConsoleInteractionTest.py b/tests/output/ConsoleInteractionTest.py
old mode 100644
new mode 100755
index 2ff1290b3..570271454
--- a/tests/output/ConsoleInteractionTest.py
+++ b/tests/output/ConsoleInteractionTest.py
@@ -46,6 +46,11 @@
 
 from tests.TestUtilities import bear_test_module, execute_coala
 
+from copy import deepcopy
+
+from coalib.parsing.DefaultArgParser import default_arg_parser
+from coalib.nestedlib.NlCore import (get_parser,
+                                     get_nl_coala_sections)
 
 STR_GET_VAL_FOR_SETTING = ('Please enter a value for the setting \"{}\" ({}) '
                            'needed by {}: ')
@@ -372,6 +377,32 @@ def test_print_affected_files(self):
                                  file_dict)
             self.assertEqual(stdout.getvalue(), '\n'+relpath(some_file)+'\n')
 
+        with retrieve_stdout() as stdout, make_temp() as some_file:
+            file_dict = {some_file: ['1\n', '2\n', '3\n']}
+            nl_file_dict = deepcopy(file_dict)
+            affected_code = (SourceRange.from_values(some_file),)
+            print_affected_files(self.console_printer,
+                                 self.log_printer,
+                                 Result('origin',
+                                        'message',
+                                        affected_code=affected_code),
+                                 file_dict)
+            self.assertEqual(stdout.getvalue(), '\n'+relpath(some_file)+'\n')
+
+        # Do not print affected files when Nested Language mode is running
+        with retrieve_stdout() as stdout, make_temp() as some_file:
+            file_dict = {some_file: ['1\n', '2\n', '3\n']}
+            nl_file_dict = deepcopy(file_dict)
+            affected_code = (SourceRange.from_values(some_file),)
+            print_affected_files(self.console_printer,
+                                 self.log_printer,
+                                 Result('origin',
+                                        'message',
+                                        affected_code=affected_code),
+                                 file_dict,
+                                 nl_file_dict=nl_file_dict)
+            self.assertEqual(stdout.getvalue(), '')
+
     def test_acquire_actions_and_apply(self):
         with make_temp() as testfile_path:
             file_dict = {testfile_path: ['1\n', '2\n', '3\n']}
@@ -516,6 +547,45 @@ def test_ask_for_actions_and_apply(self):
             self.assertEqual(generator.last_input, 3)
             self.assertNotIn('TestAction', failed_actions)
 
+    def test_ask_for_actions_and_apply(self):
+        # Applying Action in Nested language mode
+        arg_parser = default_arg_parser()
+        test_dir_path = os.path.abspath(__file__ + '/../../..')
+        test_bear_path = os.path.join(test_dir_path, 'test_bears')
+        arg_list = ['--no-config', '--handle-nested',
+                    '--bears=PEP8TestBear,Jinja2TestBear',
+                    '--languages=python,jinja2', '--files=test.py',
+                    '--bear-dirs='+test_bear_path
+                    ]
+        args = arg_parser.parse_args(arg_list)
+        nl_sections = get_nl_coala_sections(args=args)
+        nl_sections = nl_sections['cli_nl_section: test.py_nl_python']
+
+        failed_actions = set()
+        action = TestAction()
+        open_editor_action = OpenEditorAction()
+        generate_patches_action = GeneratePatchesAction()
+        do_nothing_action = DoNothingAction()
+        args = [self.console_printer,
+                nl_sections,
+                [do_nothing_action.get_metadata(), action.get_metadata(),
+                 open_editor_action.get_metadata(),
+                 generate_patches_action.get_metadata()],
+                {'DoNothingAction': do_nothing_action, 'TestAction': action,
+                 'OpenEditorAction': open_editor_action,
+                 'GeneratePatchesAction': generate_patches_action},
+                failed_actions, Result('origin', 'message'), {}, {}, {}]
+        with simulate_console_inputs('o', 'param1', 'g', 'param2') as generator:
+            action.apply = unittest.mock.Mock(side_effect=AssertionError)
+            ask_for_action_and_apply(*args)
+            self.assertEqual(generator.last_input, 1)
+            self.assertIn('OpenEditorAction', failed_actions)
+
+            action.apply = lambda *args, **kwargs: {}
+            ask_for_action_and_apply(*args)
+            self.assertEqual(generator.last_input, 2)
+            self.assertIn('GeneratePatchesAction', failed_actions)
+
     def test_default_input(self):
         action = TestAction()
         args = [self.console_printer, Section(''),

From 41114bda053d34590592230eeeccd9953f43847e Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Thu, 22 Aug 2019 01:23:30 +0530
Subject: [PATCH 15/19] Processing.py: Add Support for Nested lang mode

This PR adds the support for nested language mode. It
allows creation of new nl_sections when the Nested language
mode is run.

During the execution of instantiate_processes, we get the
file_dict of the temporary files from the nested lang parsers
instead of fetching it from the physical file.
---
 coalib/processes/Processing.py                | 83 ++++++++++++++-----
 tests/processes/ProcessingTest.py             | 34 +++++++-
 .../section_executor_test_files/test.py       |  2 +
 .../test.py.jj2.txt                           | 12 +++
 4 files changed, 109 insertions(+), 22 deletions(-)
 mode change 100644 => 100755 coalib/processes/Processing.py
 mode change 100644 => 100755 tests/processes/ProcessingTest.py
 create mode 100755 tests/processes/section_executor_test_files/test.py
 create mode 100755 tests/processes/section_executor_test_files/test.py.jj2.txt

diff --git a/coalib/processes/Processing.py b/coalib/processes/Processing.py
old mode 100644
new mode 100755
index ee2b44fba..e647b89c2
--- a/coalib/processes/Processing.py
+++ b/coalib/processes/Processing.py
@@ -31,6 +31,10 @@
 from coalib.io.FileProxy import FileDictGenerator
 from coalib.io.File import File
 
+from coalib.nestedlib.NlCore import get_parser
+from coalib.nestedlib.NlFileHandler import get_nl_file_dict
+
+from copy import deepcopy
 
 ACTIONS = [DoNothingAction,
            ApplyPatchAction,
@@ -210,7 +214,8 @@ def print_result(results,
                  file_diff_dict,
                  ignore_ranges,
                  console_printer,
-                 apply_single=False):
+                 apply_single=False,
+                 nl_file_dict=None):
     """
     Takes the results produced by each bear and gives them to the print_results
     method to present to the user.
@@ -246,14 +251,14 @@ def print_result(results,
                                         file_dict,
                                         file_diff_dict,
                                         section)
-
     print_results(None,
                   section,
                   patched_results,
                   file_dict,
                   file_diff_dict,
                   console_printer,
-                  apply_single)
+                  apply_single,
+                  nl_file_dict)
     return retval or len(results) > 0, patched_results
 
 
@@ -373,12 +378,29 @@ def instantiate_processes(section,
                              and the arguments passed to each process which are
                              the same for each object.
     """
-    filename_list = collect_files(
-        glob_list(section.get('files', '')),
-        None,
-        ignored_file_paths=glob_list(section.get('ignore', '')),
-        limit_file_paths=glob_list(section.get('limit_files', '')),
-        section_name=section.name)
+    if section.get('handle_nested', False):
+        filename_list = collect_files(
+            glob_list(section.get('orig_file_name', '')),
+            None,
+            ignored_file_paths=glob_list(section.get('ignore', '')),
+            limit_file_paths=glob_list(section.get('limit_files', '')),
+            section_name=section.name)
+        orig_file_path = glob_list(section.get('orig_file_name', ''))[0]
+        parser = get_parser(section.get('languages').value)
+        temp_file_name = section.get('files').value
+        file_lang = section.get('file_lang').value
+        nl_file_dict = get_nl_file_dict(orig_file_path=orig_file_path,
+                                        temp_file_name=temp_file_name,
+                                        lang=file_lang,
+                                        parser=parser)
+
+    else:
+        filename_list = collect_files(
+            glob_list(section.get('files', '')),
+            None,
+            ignored_file_paths=glob_list(section.get('ignore', '')),
+            limit_file_paths=glob_list(section.get('limit_files', '')),
+            section_name=section.name)
 
     # This stores all matched files irrespective of whether coala is run
     # only on changed files or not. Global bears require all the files
@@ -434,12 +456,15 @@ def instantiate_processes(section,
                       'use the `--flush-cache` flag to see them.')
         filename_list = changed_files
 
-    # Note: the complete file dict is given as the file dict to bears and
-    # the whole project is accessible to every bear. However, local bears are
-    # run only for the changed files if caching is enabled.
-    file_dict = {filename: complete_file_dict[filename]
-                 for filename in filename_list
-                 if filename in complete_file_dict}
+    if section.get('handle_nested', False):
+        file_dict = nl_file_dict
+    else:
+        # Note: the complete file dict is given as the file dict to bears and
+        # the whole project is accessible to every bear. However, local bears
+        # are run only for the changed files if caching is enabled.
+        file_dict = {filename: complete_file_dict[filename]
+                     for filename in filename_list
+                     if filename in complete_file_dict}
 
     bear_runner_args = {'file_name_queue': filename_queue,
                         'local_bear_list': local_bear_list,
@@ -557,7 +582,8 @@ def process_queues(processes,
                    console_printer,
                    debug=False,
                    apply_single=False,
-                   debug_bears=False):
+                   debug_bears=False,
+                   nl_file_dict=None):
     """
     Iterate the control queue and send the results received to the print_result
     method so that they can be presented to the user.
@@ -621,7 +647,8 @@ def process_queues(processes,
                                            file_diff_dict,
                                            ignore_ranges,
                                            console_printer=console_printer,
-                                           apply_single=apply_single
+                                           apply_single=apply_single,
+                                           nl_file_dict=nl_file_dict,
                                            )
                 local_result_dict[index] = res
             else:
@@ -645,7 +672,8 @@ def process_queues(processes,
                                    file_diff_dict,
                                    ignore_ranges,
                                    console_printer=console_printer,
-                                   apply_single=apply_single)
+                                   apply_single=apply_single,
+                                   nl_file_dict=nl_file_dict)
         global_result_dict[elem] = res
 
     # One process is the logger thread
@@ -664,7 +692,8 @@ def process_queues(processes,
                                            file_diff_dict,
                                            ignore_ranges,
                                            console_printer,
-                                           apply_single)
+                                           apply_single,
+                                           nl_file_dict=nl_file_dict)
                 global_result_dict[index] = res
             else:
                 assert control_elem == CONTROL_ELEMENT.GLOBAL_FINISHED
@@ -807,6 +836,16 @@ def execute_section(section,
     for runner in processes:
         runner.start()
 
+    # If run in nested language mode, create a nl_file_dict, that will hold the
+    # applied patches by the user. Unlike the normal execution mode of coala
+    # the applied patches are not written in a file, rather they are written/
+    # updated in the nl_file_dict.
+    nl_file_dict = {}
+    if section.get('handle_nested', False):
+        nl_file_dict = deepcopy(arg_dict['file_dict'])
+        for file in nl_file_dict:
+            nl_file_dict[file] = list(nl_file_dict[file])
+
     try:
         return (process_queues(processes,
                                arg_dict['control_queue'],
@@ -820,10 +859,12 @@ def execute_section(section,
                                console_printer=console_printer,
                                debug=debug,
                                apply_single=apply_single,
-                               debug_bears=debug_bears),
+                               debug_bears=debug_bears,
+                               nl_file_dict=nl_file_dict),
                 arg_dict['local_result_dict'],
                 arg_dict['global_result_dict'],
-                arg_dict['file_dict'])
+                arg_dict['file_dict'],
+                nl_file_dict)
     finally:
         if not (debug or debug_bears):
             # in debug mode multiprocessing and logger_thread are disabled
diff --git a/tests/processes/ProcessingTest.py b/tests/processes/ProcessingTest.py
old mode 100644
new mode 100755
index d84dbab40..16e6af374
--- a/tests/processes/ProcessingTest.py
+++ b/tests/processes/ProcessingTest.py
@@ -192,6 +192,37 @@ def test_empty_run(self):
         # No global bear
         self.assertEqual(len(results[2]), 0)
 
+    def test_nested_language_run(self):
+        config_path = os.path.abspath(os.path.join(
+            os.path.dirname(__file__),
+            'section_executor_test_files'))
+
+        testcode_p_path = os.path.join(config_path, 'test.py.jj2.txt')
+        test_dir_path = os.path.abspath(__file__ + '/../..')
+        test_bear_path = os.path.join(test_dir_path, 'test_bears')
+
+        sections, local_bears, global_bears, targets = (
+                    gather_configuration(
+                        lambda *args: self.result_queue.put(args[2]),
+                        arg_list=[
+                            '--no-config', '--handle-nested',
+                            '--bears=PEP8TestBear,Jinja2TestBear',
+                            '--bear-dirs='+test_bear_path,
+                            '--languages=python,jinja2',
+                            '--files='+testcode_p_path]))
+
+        cache = FileCache(self.log_printer, 'coala_test', flush_cache=True)
+        section_name = 'cli_nl_section: ' + testcode_p_path+'_nl_python'
+        results = execute_section(sections[section_name],
+                                  global_bears[section_name],
+                                  local_bears[section_name],
+                                  lambda *args: self.result_queue.put(args[2]),
+                                  cache,
+                                  self.log_printer,
+                                  console_printer=self.console_printer)
+        # We get no results back, because we use dummy bears.
+        self.assertFalse(results[0])
+
     def test_mixed_run(self):
         self.sections['mixed'].append(Setting('jobs', '1'))
         log_printer = ListLogPrinter()
@@ -412,7 +443,8 @@ def test_simplify_section_result(self):
                    {'file1': [Result('a', 'b')], 'file2': None},
                    {'file3': [Result('a', 'c')]},
                    None)
-        yielded, yielded_unfixed, all_results = simplify_section_result(results)
+        yielded, yielded_unfixed, all_results = simplify_section_result(
+            results)
         self.assertEqual(yielded, True)
         self.assertEqual(yielded_unfixed, True)
         self.assertEqual(len(all_results), 2)
diff --git a/tests/processes/section_executor_test_files/test.py b/tests/processes/section_executor_test_files/test.py
new file mode 100755
index 000000000..550558f66
--- /dev/null
+++ b/tests/processes/section_executor_test_files/test.py
@@ -0,0 +1,2 @@
+def sample_file():
+	print("No Lint Errors")
diff --git a/tests/processes/section_executor_test_files/test.py.jj2.txt b/tests/processes/section_executor_test_files/test.py.jj2.txt
new file mode 100755
index 000000000..36b3c9c7b
--- /dev/null
+++ b/tests/processes/section_executor_test_files/test.py.jj2.txt
@@ -0,0 +1,12 @@
+for x in y:
+{% if x is True %}
+print("This line doesn't get affected by indentatoin")
+{{ }}
+{% elif %}
+print("Bye Bye")
+{% endif %}{# if x is True #}
+{% if x in y %}
+some statement
+{% endif %}{# if x in y #}
+
+{% if x is True %} x = 20 {{  }} y = 30 {% if x is True %}

From e8488e55a581d21bc4b14c800f865f44719044ba Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Thu, 22 Aug 2019 01:35:08 +0530
Subject: [PATCH 16/19] ConfigurationGathering: Add Nested Language mode

This PR adds the support for the nested Language mode
in Configuration Gathering. Parse the cli arguments passed
to coala in Nested language mode and create coala sections.
---
 coalib/settings/ConfigurationGathering.py | 168 ++++++++++++----------
 1 file changed, 94 insertions(+), 74 deletions(-)
 mode change 100644 => 100755 coalib/settings/ConfigurationGathering.py

diff --git a/coalib/settings/ConfigurationGathering.py b/coalib/settings/ConfigurationGathering.py
old mode 100644
new mode 100755
index 010e6aa3e..15ef69914
--- a/coalib/settings/ConfigurationGathering.py
+++ b/coalib/settings/ConfigurationGathering.py
@@ -16,6 +16,8 @@
 from coalib.settings.Setting import Setting, path
 from string import Template
 
+from coalib.nestedlib.NlCore import get_nl_coala_sections, nested_language
+
 COAFILE_OUTPUT = Template('$type \'$file\' $found!\n'
                           'Here\'s what you can do:\n'
                           '* add `--save` to generate a config file with '
@@ -240,78 +242,94 @@ def load_configuration(arg_list,
                         dict(str, Section), targets: list(str)). (Types
                         indicated after colon.)
     """
-    cli_sections = parse_cli(arg_list=arg_list, arg_parser=arg_parser,
-                             args=args)
-    check_conflicts(cli_sections)
-
-    if (
-            bool(cli_sections['cli'].get('find_config', 'False')) and
-            str(cli_sections['cli'].get('config')) == ''):
-        cli_sections['cli'].add_or_create_setting(
-            Setting('config', PathArg(find_user_config(os.getcwd()))))
-
-    # We don't want to store targets argument back to file, thus remove it
-    targets = [item.lower() for item in list(
-        cli_sections['cli'].contents.pop('targets', ''))]
-
-    if bool(cli_sections['cli'].get('no_config', 'False')):
-        sections = cli_sections
+    # If args is None then nested_args will be used as a short circuit condition
+    if nested_language(args=args, arg_list=arg_list, arg_parser=arg_parser):
+        nl_sections = get_nl_coala_sections(args=args, arg_list=arg_list,
+                                            arg_parser=arg_parser)
+        check_conflicts(nl_sections)
+        sections = nl_sections
+        targets = []
+
+        str_log_level = str(list(
+                            sections.values())[0].get('log_level', '')).upper()
+        logging.getLogger().setLevel(LOG_LEVEL.str_dict.get(str_log_level,
+                                                            LOG_LEVEL.INFO))
     else:
-        base_sections = load_config_file(Constants.system_coafile,
-                                         silent=silent)
-        user_sections = load_config_file(
-            Constants.user_coafile, silent=True)
-
-        default_config = str(base_sections['default'].get('config', '.coafile'))
-        user_config = str(user_sections['default'].get(
-            'config', default_config))
-        config = os.path.abspath(
-            str(cli_sections['cli'].get('config', user_config)))
-
-        try:
-            save = bool(cli_sections['cli'].get('save', 'False'))
-        except ValueError:
-            # A file is deposited for the save parameter, means we want to save
-            # but to a specific file.
-            save = True
-
-        coafile_sections = load_config_file(config,
-                                            silent=save or silent)
-
-        sections = merge_section_dicts(base_sections, user_sections)
-
-        sections = merge_section_dicts(sections, coafile_sections)
-
-        if 'cli' in sections:
-            logging.warning('\'cli\' is an internally reserved section name. '
-                            'It may have been generated into your coafile '
-                            'while running coala with `--save`. The settings '
-                            'in that section will inherit implicitly to all '
-                            'sections as defaults just like CLI args do. '
-                            'Please change the name of that section in your '
-                            'coafile to avoid any unexpected behavior.')
-
-        sections = merge_section_dicts(sections, cli_sections)
-
-    for name, section in list(sections.items()):
-        section.set_default_section(sections)
-        if name == 'default':
-            if section.contents:
-                logging.warning('Implicit \'Default\' section inheritance is '
-                                'deprecated. It will be removed soon. To '
-                                'silence this warning remove settings in the '
-                                '\'Default\' section from your coafile. You '
-                                'can use dots to specify inheritance: the '
-                                'section \'all.python\' will inherit all '
-                                'settings from \'all\'.')
-                sections['default'].update(sections['cli'])
-                sections['default'].name = 'cli'
-                sections['cli'] = sections['default']
-            del sections['default']
-
-    str_log_level = str(sections['cli'].get('log_level', '')).upper()
-    logging.getLogger().setLevel(LOG_LEVEL.str_dict.get(str_log_level,
-                                                        LOG_LEVEL.INFO))
+        cli_sections = parse_cli(arg_list=arg_list, arg_parser=arg_parser,
+                                 args=args)
+        check_conflicts(cli_sections)
+
+        if (
+                bool(cli_sections['cli'].get('find_config', 'False')) and
+                str(cli_sections['cli'].get('config')) == ''):
+            cli_sections['cli'].add_or_create_setting(
+                Setting('config', PathArg(find_user_config(os.getcwd()))))
+
+        # We don't want to store targets argument back to file, thus remove it
+        targets = [item.lower() for item in list(
+            cli_sections['cli'].contents.pop('targets', ''))]
+
+        if bool(cli_sections['cli'].get('no_config', 'False')):
+            sections = cli_sections
+        else:
+            base_sections = load_config_file(Constants.system_coafile,
+                                             silent=silent)
+            user_sections = load_config_file(
+                Constants.user_coafile, silent=True)
+
+            default_config = str(
+                base_sections['default'].get('config', '.coafile'))
+            user_config = str(user_sections['default'].get(
+                'config', default_config))
+            config = os.path.abspath(
+                str(cli_sections['cli'].get('config', user_config)))
+
+            try:
+                save = bool(cli_sections['cli'].get('save', 'False'))
+            except ValueError:
+                # A file is deposited for the save parameter, means we want to
+                # save but to a specific file.
+                save = True
+
+            coafile_sections = load_config_file(config,
+                                                silent=save or silent)
+
+            sections = merge_section_dicts(base_sections, user_sections)
+
+            sections = merge_section_dicts(sections, coafile_sections)
+
+            if 'cli' in sections:
+                logging.warning(
+                    '\'cli\' is an internally reserved section name. '
+                    'It may have been generated into your coafile '
+                    'while running coala with `--save`. The settings '
+                    'in that section will inherit implicitly to all '
+                    'sections as defaults just like CLI args do. '
+                    'Please change the name of that section in your '
+                    'coafile to avoid any unexpected behavior.')
+
+            sections = merge_section_dicts(sections, cli_sections)
+
+        for name, section in list(sections.items()):
+            section.set_default_section(sections)
+            if name == 'default':
+                if section.contents:
+                    logging.warning(
+                        'Implicit \'Default\' section inheritance is '
+                        'deprecated. It will be removed soon. To '
+                        'silence this warning remove settings in the '
+                        '\'Default\' section from your coafile. You '
+                        'can use dots to specify inheritance: the '
+                        'section \'all.python\' will inherit all '
+                        'settings from \'all\'.')
+                    sections['default'].update(sections['cli'])
+                    sections['default'].name = 'cli'
+                    sections['cli'] = sections['default']
+                del sections['default']
+
+        str_log_level = str(sections['cli'].get('log_level', '')).upper()
+        logging.getLogger().setLevel(LOG_LEVEL.str_dict.get(str_log_level,
+                                                            LOG_LEVEL.INFO))
 
     return sections, targets
 
@@ -503,9 +521,11 @@ def gather_configuration(acquire_settings,
                                               acquire_settings,
                                               targets=targets,
                                               )
-    save_sections(sections)
-    warn_nonexistent_targets(targets, sections)
-
+    # Nested Language mode works only with cli args for now. So we don't need to
+    # save the sections.
+    if not nested_language(args=args, arg_list=arg_list, arg_parser=arg_parser):
+        save_sections(sections)
+        warn_nonexistent_targets(targets, sections)
     return (sections,
             local_bears,
             global_bears,

From 5c4e058b4221ee8256881fc0d3f95f5d72ec7f1c Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Thu, 22 Aug 2019 01:54:42 +0530
Subject: [PATCH 17/19] result_action: Add Nested Lang support

The ResultAction and the various actions for result
is updated to support Nested Language mode. The API
calls have been updates with an extra argument called
as `nl_file_dict`. It is to this dicitionary that the
result actions will be applying the changes that the
user decides to apply
---
 .../result_actions/ApplyPatchAction.py        | 18 +++--
 .../results/result_actions/DoNothingAction.py |  5 +-
 .../result_actions/GeneratePatchesAction.py   |  7 +-
 .../result_actions/IgnoreResultAction.py      |  3 +-
 .../result_actions/OpenEditorAction.py        |  0
 .../result_actions/PrintAspectAction.py       |  3 +-
 .../result_actions/PrintDebugMessageAction.py |  3 +-
 .../result_actions/PrintMoreInfoAction.py     |  3 +-
 coalib/results/result_actions/ResultAction.py | 20 ++++--
 .../ShowAppliedPatchesAction.py               |  5 +-
 .../results/result_actions/ShowPatchAction.py |  5 +-
 .../result_actions/ApplyPatchActionTest.py    | 67 +++++++++++++++++++
 12 files changed, 122 insertions(+), 17 deletions(-)
 mode change 100644 => 100755 coalib/results/result_actions/ApplyPatchAction.py
 mode change 100644 => 100755 coalib/results/result_actions/DoNothingAction.py
 mode change 100644 => 100755 coalib/results/result_actions/GeneratePatchesAction.py
 mode change 100644 => 100755 coalib/results/result_actions/IgnoreResultAction.py
 mode change 100644 => 100755 coalib/results/result_actions/OpenEditorAction.py
 mode change 100644 => 100755 coalib/results/result_actions/PrintAspectAction.py
 mode change 100644 => 100755 coalib/results/result_actions/PrintDebugMessageAction.py
 mode change 100644 => 100755 coalib/results/result_actions/PrintMoreInfoAction.py
 mode change 100644 => 100755 coalib/results/result_actions/ResultAction.py
 mode change 100644 => 100755 coalib/results/result_actions/ShowAppliedPatchesAction.py
 mode change 100644 => 100755 coalib/results/result_actions/ShowPatchAction.py
 mode change 100644 => 100755 tests/results/result_actions/ApplyPatchActionTest.py

diff --git a/coalib/results/result_actions/ApplyPatchAction.py b/coalib/results/result_actions/ApplyPatchAction.py
old mode 100644
new mode 100755
index 10d1f287b..11893fb93
--- a/coalib/results/result_actions/ApplyPatchAction.py
+++ b/coalib/results/result_actions/ApplyPatchAction.py
@@ -18,7 +18,10 @@ def apply(self,
               result,
               original_file_dict,
               file_diff_dict,
-              no_orig: bool = False):
+              nl_file_dict=None,
+              no_orig: bool = False,
+              nested_lang: bool = False,
+              ):
         """
         (A)pply patch
 
@@ -47,9 +50,16 @@ def apply(self,
                 new_filename = (diff.rename
                                 if diff.rename is not False
                                 else filename)
-                with open(new_filename, mode='w',
-                          encoding=detect_encoding(pre_patch_filename)) as file:
-                    file.writelines(diff.modified)
+
+                # Write to the original file only when we run coala is run in
+                # normal mode
+                if not nested_lang:
+                    with open(new_filename, mode='w',
+                              encoding=detect_encoding(pre_patch_filename)
+                              ) as file:
+                        file.writelines(diff.modified)
+                else:
+                    nl_file_dict[filename] = diff.modified
 
             if diff.delete or diff.rename:
                 if diff.rename != pre_patch_filename and isfile(
diff --git a/coalib/results/result_actions/DoNothingAction.py b/coalib/results/result_actions/DoNothingAction.py
old mode 100644
new mode 100755
index 219d50afd..00ce2cd9f
--- a/coalib/results/result_actions/DoNothingAction.py
+++ b/coalib/results/result_actions/DoNothingAction.py
@@ -10,7 +10,10 @@ class DoNothingAction(ResultAction):
     def apply(self,
               result,
               original_file_dict,
-              file_diff_dict):
+              file_diff_dict,
+              nl_file_dict=None,
+              nested_lang=False,
+              ):
         """
         Do (N)othing
         """
diff --git a/coalib/results/result_actions/GeneratePatchesAction.py b/coalib/results/result_actions/GeneratePatchesAction.py
old mode 100644
new mode 100755
index 98f9c5418..fb465f091
--- a/coalib/results/result_actions/GeneratePatchesAction.py
+++ b/coalib/results/result_actions/GeneratePatchesAction.py
@@ -69,14 +69,17 @@ class GeneratePatchesAction(ResultAction):
     def apply(self,
               result,
               original_file_dict,
-              file_diff_dict):
+              file_diff_dict,
+              nl_file_dict=None,
+              nested_lang=False,):
         """
         (G)enerate patches
         """
 
         console_printer = ConsolePrinter()
         log_printer = LogPrinter()
-        to_filename = sorted(result.diffs.items())[OBJECT_INDEX][FILENAME_INDEX]
+        to_filename = sorted(result.diffs.items())[
+                             OBJECT_INDEX][FILENAME_INDEX]
 
         filtered_bears = filter_bears(find_language(to_filename))
         filtered_bears.insert(0, DefaultBear())
diff --git a/coalib/results/result_actions/IgnoreResultAction.py b/coalib/results/result_actions/IgnoreResultAction.py
old mode 100644
new mode 100755
index 22a28613e..7fb53ea15
--- a/coalib/results/result_actions/IgnoreResultAction.py
+++ b/coalib/results/result_actions/IgnoreResultAction.py
@@ -42,7 +42,8 @@ def is_applicable(result: Result,
                 'seem to exist.')
 
     def apply(self, result, original_file_dict, file_diff_dict, language: str,
-              no_orig: bool = False):
+              no_orig: bool = False, nl_file_dict=None,
+              nested_lang=False):
         """
         Add (I)gnore comment
         """
diff --git a/coalib/results/result_actions/OpenEditorAction.py b/coalib/results/result_actions/OpenEditorAction.py
old mode 100644
new mode 100755
diff --git a/coalib/results/result_actions/PrintAspectAction.py b/coalib/results/result_actions/PrintAspectAction.py
old mode 100644
new mode 100755
index f933d1aec..e2a1feaf8
--- a/coalib/results/result_actions/PrintAspectAction.py
+++ b/coalib/results/result_actions/PrintAspectAction.py
@@ -16,7 +16,8 @@ def is_applicable(result: Result,
             return 'There is no aspect associated with the result.'
         return True
 
-    def apply(self, result, original_file_dict, file_diff_dict):
+    def apply(self, result, original_file_dict, file_diff_dict,
+              nl_file_dict=None, nested_lang=False,):
         """
         Print Aspec(T) Information
         """
diff --git a/coalib/results/result_actions/PrintDebugMessageAction.py b/coalib/results/result_actions/PrintDebugMessageAction.py
old mode 100644
new mode 100755
index 827caf4e1..e47058a8f
--- a/coalib/results/result_actions/PrintDebugMessageAction.py
+++ b/coalib/results/result_actions/PrintDebugMessageAction.py
@@ -16,7 +16,8 @@ def is_applicable(result: Result,
             return True
         return 'There is no debug message.'
 
-    def apply(self, result, original_file_dict, file_diff_dict):
+    def apply(self, result, original_file_dict, file_diff_dict,
+              nl_file_dict=None, nested_lang: bool = False,):
         """
         Print (D)ebug message
         """
diff --git a/coalib/results/result_actions/PrintMoreInfoAction.py b/coalib/results/result_actions/PrintMoreInfoAction.py
old mode 100644
new mode 100755
index 4e823b74c..41d0f608a
--- a/coalib/results/result_actions/PrintMoreInfoAction.py
+++ b/coalib/results/result_actions/PrintMoreInfoAction.py
@@ -16,7 +16,8 @@ def is_applicable(result: Result,
             return True
         return 'There is no additional info.'
 
-    def apply(self, result, original_file_dict, file_diff_dict):
+    def apply(self, result, original_file_dict, file_diff_dict,
+              nl_file_dict=None, nested_lang: bool = False):
         """
         Print (M)ore info
         """
diff --git a/coalib/results/result_actions/ResultAction.py b/coalib/results/result_actions/ResultAction.py
old mode 100644
new mode 100755
index c6ff19e0a..615918880
--- a/coalib/results/result_actions/ResultAction.py
+++ b/coalib/results/result_actions/ResultAction.py
@@ -37,7 +37,8 @@ def is_applicable(result,
         """
         return True
 
-    def apply(self, result, original_file_dict, file_diff_dict, **kwargs):
+    def apply(self, result, original_file_dict, file_diff_dict,
+              nl_file_dict=None, nested_lang=False, **kwargs):
         """
         No description. Something went wrong.
         """
@@ -48,7 +49,8 @@ def apply_from_section(self,
                            result,
                            original_file_dict: dict,
                            file_diff_dict: dict,
-                           section: Section):
+                           section: Section,
+                           nl_file_dict=None):
         """
         Applies this action to the given results with all additional options
         given as a section. The file dictionaries
@@ -67,7 +69,16 @@ def apply_from_section(self,
         :return:                   The modified file_diff_dict.
         """
         params = self.get_metadata().create_params_from_section(section)
-        return self.apply(result, original_file_dict, file_diff_dict, **params)
+        nested_lang = False
+        if(section.get('handle_nested', False)):
+            nested_lang = True
+            return self.apply(result, original_file_dict, file_diff_dict,
+                              nl_file_dict=nl_file_dict,
+                              nested_lang=nested_lang,
+                              **params)
+        else:
+            return self.apply(result, original_file_dict, file_diff_dict,
+                              **params)
 
     @classmethod
     def get_metadata(cls):
@@ -82,7 +93,8 @@ def get_metadata(cls):
         """
         data = FunctionMetadata.from_function(
             cls.apply,
-            omit={'self', 'result', 'original_file_dict', 'file_diff_dict'})
+            omit={'self', 'result', 'original_file_dict', 'file_diff_dict',
+                  'nl_file_dict', 'nested_lang'})
         data.name = cls.__name__
 
         return data
diff --git a/coalib/results/result_actions/ShowAppliedPatchesAction.py b/coalib/results/result_actions/ShowAppliedPatchesAction.py
old mode 100644
new mode 100755
index d887db631..eceb79331
--- a/coalib/results/result_actions/ShowAppliedPatchesAction.py
+++ b/coalib/results/result_actions/ShowAppliedPatchesAction.py
@@ -20,7 +20,10 @@ class ShowAppliedPatchesAction(ResultAction):
     def apply(self,
               result,
               original_file_dict,
-              file_diff_dict):
+              file_diff_dict,
+              nl_file_dict=None,
+              nested_lang: bool = False
+              ):
         """
         Show Applied (P)atches
         """
diff --git a/coalib/results/result_actions/ShowPatchAction.py b/coalib/results/result_actions/ShowPatchAction.py
old mode 100644
new mode 100755
index 4885a645a..a3c26a142
--- a/coalib/results/result_actions/ShowPatchAction.py
+++ b/coalib/results/result_actions/ShowPatchAction.py
@@ -87,8 +87,11 @@ def apply(self,
               result,
               original_file_dict,
               file_diff_dict,
+              nl_file_dict=None,
+              nested_lang: bool = False,
               no_color: bool = False,
-              show_result_on_top: bool = False):
+              show_result_on_top: bool = False,
+              ):
         """
         (S)how patch
 
diff --git a/tests/results/result_actions/ApplyPatchActionTest.py b/tests/results/result_actions/ApplyPatchActionTest.py
old mode 100644
new mode 100755
index 2b0c0ae02..aeb6930dc
--- a/tests/results/result_actions/ApplyPatchActionTest.py
+++ b/tests/results/result_actions/ApplyPatchActionTest.py
@@ -9,6 +9,12 @@
 from coalib.settings.Section import Section
 
 
+from coalib.parsing.DefaultArgParser import default_arg_parser
+from coalib.nestedlib.NlCore import (get_parser,
+                                     get_nl_coala_sections)
+from copy import deepcopy
+
+
 class ApplyPatchActionTest(unittest.TestCase):
 
     def test_apply(self):
@@ -178,3 +184,64 @@ def test_is_applicable_without_patch(self):
             ApplyPatchAction.is_applicable(result, {}, {}),
             'This result has no patch attached.'
         )
+
+    def test_apply_nested_language(self):
+        arg_parser = default_arg_parser()
+        test_dir_path = os.path.abspath(__file__ + '/../../..')
+        test_bear_path = os.path.join(test_dir_path, 'test_bears')
+        arg_list = ['--no-config', '--handle-nested',
+                    '--bears=PEP8TestBear,Jinja2TestBear',
+                    '--languages=python,jinja2', '--files=test.py',
+                    '--bear-dirs='+test_bear_path
+                    ]
+        args = arg_parser.parse_args(arg_list)
+        nl_sections = get_nl_coala_sections(args=args)
+        nl_sections = nl_sections['cli_nl_section: test.py_nl_python']
+        uut = ApplyPatchAction()
+        with make_temp() as f_a, make_temp() as f_b, make_temp() as f_c:
+
+            file_dict = {
+                f_a: ['1\n', '2\n', '3\n'],
+                f_b: ['1\n', '2\n', '3\n'],
+                f_c: ['1\n', '2\n', '3\n']
+            }
+            expected_file_dict = {
+                f_a: ['1\n', '3_changed\n'],
+                f_b: ['1\n', '2\n', '3_changed\n'],
+                f_c: ['1\n', '2\n', '3\n']
+            }
+
+            file_diff_dict = {}
+            nl_file_dict = deepcopy(file_dict)
+
+            diff = Diff(file_dict[f_a])
+            diff.delete_line(2)
+            uut.apply_from_section(Result('origin', 'msg', diffs={f_a: diff}),
+                                   file_dict,
+                                   file_diff_dict,
+                                   nl_sections,
+                                   nl_file_dict=nl_file_dict)
+
+            diff = Diff(file_dict[f_a])
+            diff.change_line(3, '3\n', '3_changed\n')
+            uut.apply_from_section(Result('origin', 'msg', diffs={f_a: diff}),
+                                   file_dict,
+                                   file_diff_dict,
+                                   nl_sections,
+                                   nl_file_dict=nl_file_dict)
+
+            diff = Diff(file_dict[f_b])
+            diff.change_line(3, '3\n', '3_changed\n')
+            uut.apply(Result('origin', 'msg', diffs={f_b: diff}),
+                      file_dict,
+                      file_diff_dict,
+                      nl_file_dict=nl_file_dict,
+                      nested_lang=True
+                      )
+
+            for filename in file_diff_dict:
+                file_dict[filename] = file_diff_dict[filename].modified
+
+            # In nested Language mode, only nl_file_dict is updated. We
+            # do not write to the file whenever a patch is applied.
+            self.assertEqual(nl_file_dict, expected_file_dict)

From adaad1bdb6960ba8bd0099fb72cc27aecfd63ad3 Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Thu, 22 Aug 2019 01:57:24 +0530
Subject: [PATCH 18/19] nestedlib/test_files: Add sample files for testing

---
 tests/nestedlib/test-files/test.py.txt | 2 ++
 1 file changed, 2 insertions(+)
 create mode 100755 tests/nestedlib/test-files/test.py.txt

diff --git a/tests/nestedlib/test-files/test.py.txt b/tests/nestedlib/test-files/test.py.txt
new file mode 100755
index 000000000..4d2286702
--- /dev/null
+++ b/tests/nestedlib/test-files/test.py.txt
@@ -0,0 +1,2 @@
+print("Hello Thanos")
+{% set x = {{var}} %}

From 9cebbf6be530a3230cc3e9889ad1b711313412da Mon Sep 17 00:00:00 2001
From: Naveenaidu <naveennaidu479@gmail.com>
Date: Thu, 22 Aug 2019 17:21:09 +0530
Subject: [PATCH 19/19] Fix the coverage

Rename a test file in `section_executor_test_files/test.py`
to `test.py.txt`. Having a `py` extension makes pytest
import the module when it shouldn't. This PR fixes it.
---
 tests/coalaTest.py                                              | 2 +-
 .../section_executor_test_files/{test.py => test.py.txt}        | 0
 2 files changed, 1 insertion(+), 1 deletion(-)
 rename tests/processes/section_executor_test_files/{test.py => test.py.txt} (100%)

diff --git a/tests/coalaTest.py b/tests/coalaTest.py
index 7aa516bd8..56472a110 100755
--- a/tests/coalaTest.py
+++ b/tests/coalaTest.py
@@ -425,7 +425,7 @@ def test_nested_language_run_coala(self):
             os.path.dirname(__file__),
             'processes/section_executor_test_files'))
 
-        testcode_p_path = os.path.join(config_path, 'test.py')
+        testcode_p_path = os.path.join(config_path, 'test.py.txt')
         uut_arg_list = [
                         '--no-config', '--handle-nested',
                         '--bears=PEP8TestBear,Jinja2TestBear',
diff --git a/tests/processes/section_executor_test_files/test.py b/tests/processes/section_executor_test_files/test.py.txt
similarity index 100%
rename from tests/processes/section_executor_test_files/test.py
rename to tests/processes/section_executor_test_files/test.py.txt

